# Distribution map using survey data
## An example of Starry ray in the North Sea, using INLA
#### Authors: Geert Aarts, Niels Hintzen, Jan Jaap Poos, Ingrid Tulp

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

Most of the data we collect at sea is spatially and temporally correlated, such as the International Bottom Trawl Survey (IBTS) or Beam Trawl survey data (BTS) survey data. Often we want to infer temporal or spatial trends in these data.

The statistical package INLA has the advantage over other software in R that it can combine spatial, temporal, zero-inflated, random effects etc models all in one. It therefore is very powerful and may become your one-stop-to-go package. 

This document shows some examples of analyzing survey data using INLA. The first model estimates the number of individuals per haul, taking account of the haul location (assuming spatial autocorrelation) and year (as a 'fixed effect'). Differences in counts as a result of the two surveys are accounted for by also having th survey as a fied effect. Subsequent models take lengths into account in determining the counts. In the final part, the counts are expressed per unit area, so population estimates can be made using a 'swept area' approach.    
## Preparing the R environment

```{r, eval=T, echo=FALSE}
rm(list=ls())
```

First, we need to set the path where the data is located and to load the relevant libraries. The inla package can be installed using install.packages("INLA", repos="https://inla.r-inla-download.org/R/stable"). We need the inla package, but also a number of packages for spatial analyses ('rgeos' and 'rgdal')  and for plotting the data and the results ('lattice', 'latticeExtra', 'grid','gridExtra','mapdata', and 'maptools').

```{r, eval=T, results="hide", echo=TRUE, message=FALSE, warning=FALSE}
path <- "~/WMR-INLA/data"

library(INLA); library(fields); 
library(lattice); library(latticeExtra); library(grid); library(gridExtra);
library(rgdal); library(rgeos); 
library(mapdata); library(maptools)
```

## The IBTS and BTS data

We will use the BTS and IBTS data set. In this case we downloaded the data for starry ray. These dataset contains the CPUE per length per haul can be dowloaded from datras.ices.dk. 

First we read in the IBTS dataset. From these data, the hauls in the North Sea are selected by keeping only those that are in (roundfish)areas 1-7. 

```{r, eval=T, echo=TRUE}
IBTS <- read.csv(file.path(path,"CPUE per length per haul_2017-07-12 11_18_36.csv"), stringsAsFactors = F)
IBTS <- IBTS[IBTS$Area <= 7,]
```

The lengths are stored in mm and the CPUE is stored as number per hour. "Zero hauls" are included (hauls where no individuals are counted)

```{r, eval=T, echo=TRUE}
IBTS$NoPerHaul <- round(IBTS$CPUE_number_per_hour*(IBTS$HaulDur/60))

IBTS <- within(IBTS, haulCode <-  paste(Year, Survey, Quarter, Ship, HaulNo, ShootLat, ShootLong, sep="_"))
```

We have a similar but slightly different data set for BTS. Here, the "zero hauls" have lengthclass NA and the number per haul is NA. These observations are then set to zero, so that we have the same structure as in the IBTS data set. 

```{r, eval=TRUE, echo=TRUE}
BTS  <- read.csv(file.path(path,"CPUE per length per Hour and Swept Area_2017-07-12 11_29_36.csv"), stringsAsFactors = F)

BTS[is.na(BTS$LngtClass),]$NoPerHaul <- 0
BTS[is.na(BTS$LngtClass),]$LngtClass <- 0
```

The BTS swept area estimate is rounded, and thus not very useful. We recalculate it: the disatnce and beam width are in m, so the surface is in m2, and divided by 11e+06 to get km2
```{r, eval=TRUE, echo=TRUE}
# there are some negative distances. We make those  NA, and infer their surface later 
BTS[!is.na(BTS$Distance) & BTS$Distance < 0,]$Distance <- NA

#now calculate surface
BTS$surface <- (BTS$Distance * BTS$BeamWidth)/1e+06

# summary of the surface gives number of NAs, and whether there are negative values
summary(BTS$surface)
summary(BTS$HaulDur)

#make haul code
BTS <- within(BTS, haulCode <- paste(Year, Survey, Quarter, Ship, HaulNo, ShootLat, ShootLong, sep="_"))
```

The BTS and IBTS datasets need to be combined the two sets into one, using rbind() to combine them by rows. The datasets can only be combined if they have the same columns. The columns that are shared by the two data sets are found using intersect().
```{r, eval=TRUE, echo=TRUE}
cols <- intersect(colnames(BTS), colnames(IBTS))
cpue <- rbind(BTS[,cols],IBTS[,cols])

#remove CPUE per hour that we do not need now that we have counts
cpue <- cpue[,!names(cpue)=="CPUE_number_per_hour"]
```

Now that the IBTS and BTS data sets are combined we want to make a set where we have counts for all hauls and all lenghts. This means first making an dentifier for each unique haul (based on the information we have for all the hauls). This identifier is used to make a "trawllist" where all the information for the hauls is stored together with its unique identifier.

Once the trawllist is make we use expand.grid() to make a combination of all hauls and lenght classes. This set is merged with our original data set.
```{r, eval=TRUE, echo=TRUE}
trawllist <- cpue[!duplicated(cpue$haulCode),!names(cpue) %in% c("Species","AphiaID","NoPerHaul","Sex", "LngtClass")]

#expand grid 
haulsLengths <- expand.grid(haulCode=unique(cpue$haulCode),LngtClass=unique(cpue$LngtClass), stringsAsFactors = F)
full_cpue <- merge(haulsLengths,cpue[names(cpue) %in% c("haulCode", "LngtClass","NoPerHaul")], all.x=T)
rm(haulsLengths)
```

After we merged all possible combinations with the data we now have NAs for those lengts and hauls where the catch is zero, and so we set those to zero. This data is subsequently merged to the trawllist so that we have all information together. 
```{r, eval=TRUE, echo=TRUE}
full_cpue[is.na(full_cpue$NoPerHaul),]$NoPerHaul <- 0
full_cpue  <- merge(full_cpue,trawllist, all.x=T)
```

The records that have lenghts equal to zero (that indicated zero hauls in our original set ) now need to be removed because we have all the information we need (these hauls now have zero catch for the full length range observed in the survey). 

```{r, eval=TRUE, echo=TRUE}
#now remove zero lengths
full_cpue <- full_cpue[full_cpue$LngtClass > 0,]
```

In addition, there are some observations that are highly unlikely: For instance there is a single observation of an individual of 100 cm (in 1977). This is highly suspicious, becuse it is far larger than than any other observation, and likely due to species mis-identification. This can be seen in the histogram of length observations below:


```{r, eval=TRUE, echo=TRUE, dpi=600}
hist(full_cpue[full_cpue$NoPerHaul >0,]$LngtClass, breaks=100, xlab="Length (mm)", main="Histogram of observed lengths")
abline(v=990, col="red")
```

We remove this observation from the data. Note that when the length information is included in the analyses a further selection is made for the lengths.

```{r, eval=TRUE, echo=TRUE}
#remove single unlikely large individual (of 1 m length) 
full_cpue <- full_cpue[full_cpue$LngtClass < 990,]
head(full_cpue)
```

For our spatial correlation we will need an isomorphic coordinate system. Therefore we transform the latitudes and longitudes to UTM coordinates. these UTM coordinates are given in meters, so we divide them by 1000 to get kilometers.
```{r, eval=TRUE, echo=TRUE}
UTM <- project(cbind(full_cpue$ShootLong, full_cpue$ShootLat), "+proj=utm +zone=31U ellps=WGS84") 

full_cpue$Xkm <- UTM[,1]/1000
full_cpue$Ykm <- UTM[,2]/1000
```

The INLA code does not like special characters in some of the variable names, like the hyphen in "NS-IBTS". Therefore we rename the survey to NSIBTS. 
```{r, eval=TRUE, echo=TRUE}
full_cpue <- transform(full_cpue, Survey=gsub("-","",Survey))
```

## Subsetting and length aggregation

We still have a lot of data (`r nrow(full_cpue)`), Because these are just here as example, we will subset the data, and start our analysis from a fiven year. That year is stored in startyr.    
```{r, eval=TRUE, echo=TRUE}
startyr <- 2013
cpue_subset <- full_cpue[full_cpue$Year >= startyr,]
```

In this example we thus start from `r startyr`.  The earlier we start, the more information we will obtain from the analysis on the annual changes in the count data. However, including more data also means we require more memory to store the model, and wait longer for the model to run. If too much data is used in the inla model, so that more computer memory is required than you have available, the model will crash. Now we have `r  nrow(cpue_subset)` rows left in cpue_subset. We start with a very simple analysis where we do not take length into account, and only analyse numbers per haul. Hence we aggregate the counts per haul.

```{r, eval=TRUE, echo=TRUE}
cpue_subset <- aggregate(NoPerHaul ~ haulCode + Survey +  Quarter + Ship + Gear  + HaulNo + Year + HaulDur + ShootLong + ShootLat +  Xkm + Ykm +  Depth, data= cpue_subset,FUN="sum")
```
After the aggregation (now that the length information is removed) we have `r  nrow(cpue_subset)` rows in the data set. To give us a quick impression of the data we plot it in a map. The two surveys have different colors, red being the IBTS hauls and black being the BTS hauls. The size of the circles indicate the counts in each haul

```{r, eval=TRUE, echo=TRUE, dpi=600}
par(mfrow=c(1,2))
plot(cpue_subset$ShootLong,cpue_subset$ShootLat, 
     cex=0.1, 
     col=as.numeric(as.factor(cpue_subset$Survey)),
     xlab="Longitude", ylab="Lattitude", main="Location of all hauls" )
map("world",add=T)

plot(cpue_subset$ShootLong,cpue_subset$ShootLat, 
     cex=(cpue_subset$NoPerHaul)/10, 
     col=as.numeric(as.factor(cpue_subset$Survey)),
     xlab="Longitude", ylab="Lattitude",  main="Counts per hauls" )
map("world",add=T)
```
Clearly the IBTS hauls cover a larger part of the North Sea, but the large catches for both are located in the same areas. 

We also plot a quick histogram of the counts, to give us an impression of the statistical distribution of the data.

```{r, eval=TRUE, echo=TRUE}
par(mfrow=c(1,2))
hist(cpue_subset[cpue_subset$Survey == "BTS",]$NoPerHaul, 200, xlab= "Number per haul", main="Histogram of counts per haul BTS")
hist(cpue_subset[cpue_subset$Survey == "NSIBTS",]$NoPerHaul, 200, xlab= "Number per haul", main="Histogram of counts per haul IBTS")

```

The count data is clearly quite skewed, with lots of zeros and small values, and very few large counts. Because of this distribution and because  these are counts, a Poisson and a negative binomial distribution will be used in the inla model.  

## Making a spatial mesh for the data

The UTM coordinates of the data set are combined into a Loc (location) dataset. That data set will be used later to generate spatial meshes for the data.   
```{r, eval=TRUE, echo=TRUE}
Loc <- cbind(cpue_subset$Xkm , cpue_subset$Ykm )
```

Next we need a mesh for the spatial data. Because we do not want our spatial correlations to pass landmasses (e.g. Denmark) we first make a nonconvex hull of the data points using inla.nonconvex.hull(). This convex hull is used as a boundary for making a 2d mesh. The generation of the actual mesh is done using inla.mesh.2d(). That function takes several arguments, incuding "cutoff" and "max.edge". These arguments specify how fine the final mesh will be. Finer meshes will be able to capture smaller scale spatial correlations, but require more comuting time in the inla model.

```{r, eval=TRUE, echo=TRUE}
ConvHull <- inla.nonconvex.hull(Loc, convex=-0.02, resolution=90)
mesh1a   <- inla.mesh.2d(boundary = ConvHull,  max.edge=c(30))
```

As an alternative to using the nonconvex hull function to generate a boundary,, we can also take the shapefile of the North Seaas the boundary of the mesh, which makes prediction in the future easier, as we know no record can be found outside the North Sea area (give or take evolution). We first load the ICES shapefiles which were downloaded from http://gis.ices.dk/sf/. We load this shapefiles, merge layers together, transform to UTM, convert UTM to km rather than meters and finally create a mesh. 
```{r, eval=TRUE, echo=TRUE}
ICESareas <- readShapePoly(file.path(path,"ICES_Areas_20160601_dense"))
NorthSea  <- subset(ICESareas,SubArea==4)
NorthSea  <- gUnionCascaded(NorthSea)
proj4string(NorthSea) <- c("+proj=longlat")
NorthSeaUTM <- spTransform(NorthSea,CRS("+proj=utm +zone=31"))

NS.border <- inla.sp2segment(NorthSeaUTM)
NS.border$loc <- NS.border$loc/1000

mesh1b      <- inla.mesh.2d(boundary=NS.border, cutoff=3,max.edge=c(30))
```

The meshes can be plotted using the plot() function on the mesh object. Once the mesh is plotted, the locations of the samples (stored in the Loc object) can be overlayed using points(). Below, the two meshes are plotted side-by-side.

```{r, eval=TRUE, echo=TRUE, dpi=600}
par(mfrow=c(1,2))
plot(mesh1a)
points(Loc, col = 1, pch = 16, cex = 0.3)
plot(mesh1b)
points(Loc, col = 1, pch = 16, cex = 0.3)
```

## Making the projector matrix and the spde 

Once the 2d mesh is made we construct a observation/prediction weight matrix for the model. This is also called the "projector matrix".
```{r, eval=TRUE, echo=TRUE}
# 2. Define the weighting factors a_ik (also called the projector matrix).
A1      <- inla.spde.make.A(mesh  = mesh1a, loc   = Loc)
dim(A1)
```
The first dimension of the projector matrix has the size of the number of observations (here `r dim(A1)[1]`), and the second dimension of the projector matrix is the number of nodes in the mesh (here `r dim(A1)[2]`).
```{r, eval=TRUE, echo=TRUE}
# 3. Define the spde
spde  <- inla.spde2.matern(mesh1a)

w.st <- inla.spde.make.index('w', n.spde = spde$n.spde)
```

## Making the stack

The stack allows INLA to build models with complex linear predictors. Here have a SPDE model combined with covariate fixed effects and an intercept at n hauls.

Before making the stack we need to convert all fixed effects that are factors in the INLA model.
```{r, eval=T, echo=T}
cpue_subset$fYear   <- as.factor(cpue_subset$Year)
cpue_subset$fSurvey <- as.factor(cpue_subset$Survey)
```

Note that in code below the names in the model matrix should not contain any special characters! This is why we renamed the "NS-IBTS" survey to "NSIBTS"
```{r, eval=T, echo=T}
# 5. Make a stack. In this process we tell INLA at which points on the mesh we sampled the response variable and the covariates. 
Xmatrix <- model.matrix(~ fYear + fSurvey +  HaulDur,  data = cpue_subset)
head(Xmatrix)
```

This Xmatrix contains the model matrix with the fixed effects, including the intercept (The column for the intercept is named "(Intercept)", and it is 1 for all observations). However, in the next step the intercept is removed from the model matrix. The intercept is then included when making the stack, and named "Intercept" (without brackets).

```{r, eval=T, echo=T}
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack1 <- inla.stack(
    tag  = "Fit",
    data = list(y = cpue_subset$NoPerHaul),    
    A    = list(1,1, A1),                      
    effects = list( 
       Intercept=rep(1,N),
       X=X, #Covariates
       w=w.st))                  #Spatial field
```

## Making the model formula and running the INLA model

The model formula used in the inla model is generated from the names of the model matrix, combined with the intercept term and the spatial correlation model ("f(w, model=spde)").

Subsequently, two inla models are run, one assuming that the data are Poisson distributed, and another model assuming that the data are negative binomial distributed.

```{r, eval=T, results='hide', echo=T, message=FALSE, warning=FALSE}
fsp <- parse(text=c("y ~ -1 + Intercept + ",paste(c(names(X)," f(w, model = spde)"),collapse =" + ")))

INLA:::inla.dynload.workaround() 
I1p <- inla(eval(fsp), family = "poisson", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))

I1nb <- inla(eval(fsp), family = "nbinomial", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))
```
Once the INLA models are run, a summary can be printed for the two models. This summary contains much of the relevant information for the models.

```{r, eval=T, echo=T}
summary(I1p)

summary(I1nb)
```
Plot the histograms of observations and fits for both models 

```{r, eval=T, echo=T}
idx <- inla.stack.index(Stack1, tag= 'Fit')$data

par(mfrow=c(1,2))
hist(round(I1p$summary.fitted.values[idx,"mean"],0),300, xlim=c(0,50), ylim=c(0,4000), xlab="Counts", main="Histogram of observed versus predicted counts")
obshist <- table(cpue_subset$NoPerHaul)
points(x=names(obshist), y=c(obshist), pch=20)

hist(round(I1nb$summary.fitted.values[idx,"mean"],0),200, xlim=c(0,50), ylim=c(0,4000), xlab="Counts", main="Histogram of observed versus predicted counts")
obshist <- table(cpue_subset$NoPerHaul)
points(x=names(obshist), y=c(obshist), pch=20)

```


```{r, eval=T, echo=T, fig.width=8, fig.height=4, dpi=600}
wproj <- inla.mesh.projector(mesh1a, xlim = range(Loc[,1]), ylim = range(Loc[,2])) 

wm.pm100100  <- inla.mesh.project(wproj, I1nb$summary.random$w$mean)
wsd.pm100100 <- inla.mesh.project(wproj, I1nb$summary.random$w$sd)
    
grid     <- expand.grid(x = wproj$x, y = wproj$y)
grid$zm  <- as.vector(wm.pm100100)   
grid$zsd <- as.vector(wsd.pm100100)   

wld <- map('world', xlim=c(-5,15), ylim=c(47,62),plot=FALSE)
wld <- data.frame(lon=wld$x, lat=wld$y)

UTMmap <- project(cbind(wld$lon, wld$lat), "+proj=utm +zone=31U ellps=WGS84")
UTMmapFinal <- data.frame("xm"  =UTMmap[,1]/1e3, "ym" = UTMmap[,2]/1e3)

p1 <- levelplot(zm ~ x * y  ,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15+0.1, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

p2 <- levelplot(zsd ~ x * y,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior sd spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15+0.1, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

grid.arrange(p1,p2, ncol=2)
  
```

Wat happens here?

```{r, eval=FALSE, echo=T}

tcoo <- rbind(c(0.3, 0.3), c(0.5, 0.5), c(0.7, 0.7))
inla.nonconvex.hull
dim(Ap <- inla.spde.make.A(mesh = mesh1, loc = tcoo))
## [1] 3 505
x0 <- c(0.5, 0.5, 0.5)
#To do a fully Bayesian analysis, we include the target locations on the estimation process by
#assigning NA for the response at these locations. Defining the prediction stack
stk.pred <- inla.stack(tag='pred', A=list(Ap, 1), data=list(y=NA), ## response as NA
effects=list(s=1:spde$n.spde, data.frame(x=x0, b0=1)))
#Fit the model again with the full stack

stk.full <- inla.stack(stk.e, stk.pred)
p.res <- inla(formula, data=inla.stack.data(stk.full), ## full stack
control.predictor=list(compute=TRUE, ## compute the predictor
A=inla.stack.A(stk.full))) ## using full stack data
#Get the prediction data index and collect the PMD to work with
pred.ind <- inla.stack.index(stk.full, tag = "pred")$data
ypost <- p.res$marginals.fitted.values[pred.ind]
#Visualize PMD for the linear predictor at target locations with commands bellow
names(ypost) <- paste('y', seq_along(ypost), sep='_'); library(plyr)
xyplot(y~x | .id, ldply(ypost), panel='llines', xlab='y', ylab='Density')
#In INLA we have some functions to work with marginals distributions
apropos("marginal")
## [1] "inla.dmarginal" "inla.emarginal" "inla.hpdmarginal"
## [4] "inla.mmarginal" "inla.pmarginal" "inla.qmarginal"
## [7] "inla.rmarginal" "inla.smarginal" "inla.tmarginal"
inla.mmarginal(ypost[[1]]) ## mode
## [1] 1.697
inla.qmarginal(c(0.15, 0.7), ## quantiles
ypost[[1]])
## [1] 1.345 1.875
inla.pmarginal(inla.qmarginal(
0.3, ypost[[1]]), ypost[[1]])
## [1] 0.3

```


## Including length in the analysis

Owing to ontogenetic niche shifts we expect that the spatial distribution of small indivduals is different from the spatial distribution of large indivuals. Hence we want to include a length component in the spatial distribution of the counts.

First we need to make a new subset of the data that includes the length information (and leaving out the aggregation step in our earlier analysis). We use the same starting year as was done for the previous analysis: `r startyr`.

```{r, eval=TRUE, echo=TRUE}
# make selection of  fullset.
cpue_subset <- full_cpue[full_cpue$Year >= startyr,]
```

Let's make 5 cm classes instead of 1 cm classes. This reduces the number of observations. We use round to achieve this. Remember that the units of the length measurements is mm. 

Once we have 5 cm lenght classes, we need aggregate() to sum the numbers per haul within our new length bins. Becaus we need the other info in the data set as well we include all variables in the aggregate. 

```{r, eval=TRUE, echo=TRUE}
cpue_subset$LngtClass <- round(cpue_subset$LngtClass/50)*50

cpue_subset <- aggregate(NoPerHaul~ LngtClass + haulCode + Survey + Quarter + Ship + Gear  + HaulNo + Year + HaulDur + ShootLong +
                                    ShootLat + Xkm + Ykm +  Depth, data= cpue_subset,FUN="sum")
```


Below, we inspect the length range of observations. There are no individuals with lengths over 600 mm observed. Hence, we remove those lengthclasses. If there are too many subsequent lenght classes with only zeros, the model will fail, giving a warning that one of the eigenvalues is negative.  

```{r, eval=T, echo=T}
aggregate(NoPerHaul~LngtClass, data=cpue_subset, FUN= "sum")
cpue_subset <- cpue_subset[cpue_subset$LngtClass >   0,]
cpue_subset <- cpue_subset[cpue_subset$LngtClass < 650,]
```


Because we now have combinations for all hauls and several length classes, the subset of data (since 2009) is still very big. It has`r  nrow(cpue_subset)` observations. In order to reduce the number of observaions used in the INLA model, we take all non-zero observations but we subsample the zero observations. The remaining zero observations willneed to receive a higher weight in the final model. Note that this is not yet implemented.  
```{r, eval=TRUE, echo=TRUE}
#cpue_subset_temp  <- cpue_subset[cpue_subset$NoPerHaul > 0,]
#cpue_subset_temp  <-rbind(cpue_subset_temp, cpue_subset[sample(which(cpue_subset$NoPerHaul==0),40000),])

#cpue_subset <- cpue_subset_temp
```


As before, The UTM coordinates of the observations are combined into a Loc (location) dataset. That dataset is used to create a mesh in the next step.  
```{r, eval=TRUE, echo=TRUE}
Loc <- cbind(cpue_subset$Xkm , cpue_subset$Ykm )
```

Next we need a mesh for the spatial data. Because we do not want our spatial correlations to pass landmasses (e.g. Denmark) we first make a convex hull of the data points using inla.nonconvex.hull(). This convex hull is used as a boundary for making a 2d mesh. 

```{r, eval=TRUE, echo=TRUE}

ConvHull <- inla.nonconvex.hull(Loc, convex=-0.02, resolution=90)
mesh2a    <- inla.mesh.2d(boundary = ConvHull,  max.edge=c(30))
plot(mesh2a)
points(Loc, col = 1, pch = 16, cex = 0.5)
```

Next we inspect the length range in the data by making a histogram of length observations. This histogram can be used to define the locations ofa number of "knots" along the length range that we will later use for our analysis. More knots means a longer computing time (but a higher degree of flexibility in the length component of the spatial correlation). 

There are no individuals with lengths over 680 mm observed. Hence, we remove those lengthclasses (with only zeros) from the data set and define the knots to be within the new length range 

```{r, eval=T, echo=T}
hist(cpue_subset$LngtClass,200)
knots <- seq(from = 50, to = 550, by = 100)
knots 
```

Using the `r length(knots)` knots as locations, we make a 1 dimensional mesh.   
```{r, eval=T, echo=T}
  
# One-dimensional mesh for length class. See the time series module
mesh.t <- inla.mesh.1d(loc = knots)
```

In this mesh.t object, the dimensions can be checked using mesh.t$loc (for the locations) and mesh.t$n (the number of locations). The code below confirms that there are `r mesh.t$n` locations, and those are at the values of the knots object. 
```{r, eval=T, echo=T}
mesh.t$n
mesh.t$loc
```
 
Now that there is a 1 dimensional mesh for the lengths, we use it to construct a observation/prediction weight matrix ("projector matrix") based on the spatial mesh that we already created earlier (mesh1) and our new mesh for the lengths. The lengths are used in the "group model". The new projector matrix is names A2 to distinguish it from the projector matrix of the previous model.

```{r, eval=T, echo=T}
# 2. Define the weighting factors a_ik (projector matrix).
NGroups <- length(knots) 
A2      <- inla.spde.make.A(mesh  = mesh2a,
                            loc   = Loc,
                            group = cpue_subset$LngtClass, 
                       group.mesh = mesh.t)
dim(A2) 

# 3. Define the spde
spde  <- inla.spde2.matern(mesh2a)
```

We need to make an inla.spde model object for a Matern model, but we still have that available from the model without size structure. That object was named "spde". We use it to make a list of named index vectors for the SPDE model. Note that the command for making the list of index vectors now includes an argument for the groups. 

```{r, eval=T, echo=T}
w.st <- inla.spde.make.index('w', 
                             n.spde = spde$n.spde, 
                             n.group = NGroups)
```


Before making the stack we need to convert all fixed effects that are factors in the INLA model.
```{r, eval=T, echo=T}
cpue_subset$fYear   <- as.factor(cpue_subset$Year)
cpue_subset$fSurvey <- as.factor(cpue_subset$Survey)
```

Next we make a new stack. For this we need a model matrix. Although the fixed effects are the same as in the previous model, we still need to make a new model matrix because the data now include the length structure. 

```{r, eval=T, echo=T}
# 5. Make a stack. 
Xmatrix <- model.matrix(~  fYear + fSurvey +  HaulDur,  data = cpue_subset)

head(Xmatrix)
```
This Xmatrix contains the model matrix with the fixed effects, including the intercept (The column for the intercept is named
 "(Intercept)", and it is 1 for all observations). However, in the next step the intercept is removed from the model matrix.
 The intercept is then included when making the stack, and named "Intercept" (without brackets). 

```{r, eval=T, echo=T}
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack2 <- inla.stack(
  tag  = "Fit",
  data = list(y = cpue_subset$NoPerHaul),    
  A    = list(1,1, A2),                      
  effects = list(  
    Intercept = rep(1, N),       
    X = as.data.frame(X), # Covariates
    w.st))                # Spatial-temp field  

```

```{r, eval=F, echo=T}
fsp <- parse(text=c("y ~ -1 + Intercept + ",
                    paste(c(names(X)," f(w, model = spde, group =       w.group, control.group = list(model = 'ar1'))"),collapse =" + ")))
```

```{r, eval=F, echo=T}
I2nb <- inla(eval(fsp), family = "nbinomial",
           data=inla.stack.data(Stack2),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack2)))
```

```{r, eval=F, echo=T}
summary(I2nb)
```

We still have The "UTMmap" object for creating the maps from the previous analysis.

```{r, eval=F, echo=T}
w <- I2nb$summary.random$w$mean
# length of w is mesh$n * NGroups
wproj <- inla.mesh.projector(mesh2a, xlim = range(Loc[,1]), ylim = range(Loc[,2])) 

grid <- expand.grid(length=knots, x = wproj$x, y = wproj$y,zm=NA)

for (i in knots){
    w.pm100100 <- inla.mesh.project(wproj,w[w.st$w.group==which(i==knots)])
    grid[grid$length==i,]$zm <- as.vector(w.pm100100)  
}
```

Next we print the grid, which is now estimated at each knot. The observed counts for the length class at each knot are included in each panel. 
```{r, eval=F, echo=T, dpi=600}
print(levelplot(zm ~ x * y |length,
          data = grid,
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset[cpue_subset$LngtClass == grid[subscripts[1],]$length,]$Xkm,
                        y = cpue_subset[cpue_subset$LngtClass == grid[subscripts[1],]$length,]$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset[cpue_subset$LngtClass ==grid[subscripts[1],]$length,]$NoPerHaul/15, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black'))
```

## Including length in the survey catchability

```{r, eval=T, echo=T}
# 5. Make a stack. 
Xmatrix <- model.matrix(~  fYear + fSurvey + HaulDur,  data = cpue_subset)

head(Xmatrix)
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack3 <- inla.stack(
  tag  = "Fit",
  data = list(y = cpue_subset$NoPerHaul),    
  A    = list(1,1, A2),                      
  effects = list(  
    Intercept = rep(1, N),       
    X = as.data.frame(X), # Covariates
    w.st))                # Spatial-temp field  

```

```{r, eval=FALSE, echo=T}
fsp <- parse(text=c("y ~ -1 + Intercept + ",
                    paste(c(names(X)," f(w, model = spde, group =       w.group, control.group = list(model = 'ar1'))", "f(LngtClass, group=fSurvey,'rw2')",collapse =" + ")))
```

```{r, eval=FALSE, echo=T}
I3nb <- inla(eval(fsp), family = "nbinomial",
           data=inla.stack.data(Stack3),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack3)))
```

```{r, eval=FALSE, echo=T}
summary(I3nb)
```

## Using swept area estimates
We still have the IBTS data available in the cpue_IBTS object, but that does not provide the swept area. For this, we need to read in the HH records of the exchange file 

File contains HH records in exchange files for IBTS. NA for door spread and distance are coded as -9, so make NAs of those. 
```{r, eval=T, echo=T}
IBTSHH <- read.csv(file.path(path,"Exchange Data_2017-07-14 09_26_25.csv"), stringsAsFactors = F)

IBTSHH <- within(IBTSHH, haulCode <-  paste(Year, Survey, Quarter, Ship, HaulNo, ShootLat, ShootLong, sep="_"))

IBTSHH[IBTSHH$DoorSpread == -9,]$DoorSpread <- NA
IBTSHH[IBTSHH$Distance == -9,]$Distance <- NA
IBTSHH[IBTSHH$WingSpread == -9,]$WingSpread <- NA
``` 

Plot  haul duration, doorspread and wingspread, haulduration is in minutes, wing spread and doorspread are in meters. 

```{r, eval=TRUE, echo=TRUE, dpi=600}
par(mfrow=c(1,2))
hist(IBTSHH$HaulDur,120, xlim=c(0,120))

plot(IBTSHH$WingSpread,IBTSHH$DoorSpread)
```

Multiply  wing spread by distance, which is also in metres. The rsulting surface is thus in m2.
```{r, eval=T, echo=T}
IBTSHH$surface <- (IBTSHH$Distance * IBTSHH$WingSpread)/1e+06
```

Select only relevant variables, and remove all hauls longer than 90 minutes
```{r, eval=T, echo=T}
IBTSHH <- IBTSHH[names(IBTSHH) %in% c("haulCode", "surface", "HaulDur","Doorspread","Distance","WingSpread","Warplngt")]
IBTSHH <- IBTSHH[IBTSHH$HaulDur<=90,]
```

Plot surface against duration hoping to find corr, use linear model to predict surface from haul duration, assuming model withuot intercept
```{r, eval=TRUE, echo=TRUE, dpi=600}
plot(x=IBTSHH$HaulDur,y=IBTSHH$surface)
linmod <- lm(surface~ -1 + HaulDur, data=IBTSHH)
summary(linmod)
abline(linmod)

IBTSHH[is.na(IBTSHH$surface),]$surface <- as.numeric(predict(linmod,newdata=IBTSHH))[is.na(IBTSHH$surface)]
```

Merge haulinfo to full cpue set, after removing haulduration from haul data (because we have it in the CPUE set already)
```{r, eval=T, echo=T}
IBTSHH$HaulDur <- NULL
IBTS <- merge(IBTS, IBTSHH,by= "haulCode", all.x=T, all.y=F)
```

Also infer missing surfaces from hauldur for BTS
```{r, eval=TRUE, echo=TRUE, dpi=600}
plot(x=BTS$HaulDur,y=BTS$surface)
linmod <- lm(surface~ -1 + HaulDur, data=BTS)
summary(linmod)
abline(linmod)

BTS[is.na(BTS$surface),]$surface <- as.numeric(predict(linmod,newdata=BTS))[is.na(BTS$surface)]
```

Next we combine the two sets into one.
```{r, eval=TRUE, echo=TRUE}
cols <- intersect(colnames(BTS), colnames(IBTS))
cpue <- rbind(BTS[,cols],IBTS[,cols])
```

Now that the IBTS and BTS data sets are combined we want to make a set where we have counts for all hauls and all lenghts. This means first making an dentifier for each unique haul (based on the information we have for all the hauls). This identifier is used to make a "trawllist" where all the information for the hauls is stored.

Once the trawllist is make we use epand.grid() to make a combination of all hauls and lenght classes. This set is merged with our original data set.
```{r, eval=TRUE, echo=TRUE}
trawllist <- cpue[!duplicated(cpue$haulCode),!names(cpue) %in% c("Species","AphiaID","NoPerHaul","Sex", "LngtClass")]

#expand grid 
haulsLengths <- expand.grid(haulCode=unique(cpue$haulCode),LngtClass=unique(cpue$LngtClass), stringsAsFactors = F)
full_cpue <- merge(haulsLengths,cpue[names(cpue) %in% c("haulCode", "LngtClass","NoPerHaul")], all.x=T)
rm(haulsLengths)
head(full_cpue)
```

After we merged all possible combinations with the data we now have NAs for those lengts and hauls where the catch is zero, and so we set those to zero. This data is subsequently merged to the trawllist so that we now have all information together. 
```{r, eval=TRUE, echo=TRUE}
full_cpue[is.na(full_cpue$NoPerHaul),]$NoPerHaul <- 0
full_cpue  <- merge(full_cpue,trawllist, all.x=T)
```

The records that have lenghts equal to zero (that indicated zero hauls in our original set ) now need to be removed because we have all the information we need (these hauls now have zero catch for the full length range observed in the survey). 

In addition, there are some observations that are highly unlikely: For instance there is a single observation of an individual of 100 cm (in 1977). This is suspicious, and we remove it from the data. 


```{r, eval=TRUE, echo=TRUE}
#now remove zero lengths
full_cpue <- full_cpue[full_cpue$LngtClass> 0,]
full_cpue <- full_cpue[full_cpue$LngtClass< 990,]
```

For our spatial correlation we will need an isomorphic coordinate system. Therefore we transform the latitudes and longitudes to UTM coordinates. these UTM coordinates are given in meters, so we divide them by 1000 to get kilometers.
```{r, eval=TRUE, echo=TRUE}
UTM <- project(cbind(full_cpue$ShootLong, full_cpue$ShootLat), "+proj=utm +zone=31U ellps=WGS84") 

full_cpue$Xkm <- UTM[,1]/1000
full_cpue$Ykm <- UTM[,2]/1000
```

The INLA code does not like special characters in some of the variable names, like the hyphen in "NS-IBTS". Therefore we rename the survey to NSIBTS. 
```{r, eval=TRUE, echo=TRUE}
full_cpue <- transform(full_cpue, Survey=gsub("-","",Survey))
```

## Subsetting and length aggregation

We still have a lot of data (`r nrow(full_cpue)`), Because these are just here as example, we will subset the data, and start our analysis again from startyr `r startyr`.    
```{r, eval=TRUE, echo=TRUE}
cpue_subset <- full_cpue[full_cpue$Year >= startyr,]
```

The earlier we start, the more information we will obtain from the analysis on the annual changes in the count data. However, including more data also means we require more memory to store the model, and wait longer for the model to run. If too much data is used in the inla model, so that more computer memory is required than you have available, the model will crash. Now we have `r  nrow(cpue_subset)` rows left in cpue_subset. We start with a very simple analysis where we do not take length into account, and only analyse numbers per haul. Hence we aggregate the counts per haul. Because we now want to include the surface rather than the duration we include that in the aggregate.

```{r, eval=TRUE, echo=TRUE}
cpue_subset <- aggregate(NoPerHaul ~ haulCode + Survey +  Quarter + Ship + Gear + HaulNo + Year + HaulDur + surface + ShootLong + ShootLat +  Xkm + Ykm +  Depth, data= cpue_subset,FUN="sum")
```

We do not plot the exploraory data analayses again.

## Making a spatial mesh for the data

The UTM coordinates of the data set are combined into a Loc (location) dataset. That data set will be used later to generate spatial meshes for the data.   
```{r, eval=TRUE, echo=TRUE}
Loc <- cbind(cpue_subset$Xkm , cpue_subset$Ykm )
```

Next we need a mesh for the spatial data. Because we do not want our spatial correlations to pass landmasses (e.g. Denmark) we first make a nonconvex hull of the data points using inla.nonconvex.hull(). This convex hull is used as a boundary for making a 2d mesh. The generation of the actual mesh is done using inla.mesh.2d(). That function takes several arguments, incuding "cutoff" and "max.edge". These arguments specify how fine the final mesh will be. Finer meshes will be able to capture smaller scale spatial correlations, but require more comuting time in the inla model.

```{r, eval=TRUE, echo=TRUE, dpi=600}
ConvHull <- inla.nonconvex.hull(Loc, convex=-0.02, resolution=90)
mesh1a   <- inla.mesh.2d(boundary = ConvHull,  max.edge=c(30))
plot(mesh1a)
points(Loc, col = 1, pch = 16, cex = 0.3)
```

The alternative from the first examples can of course also be used.
The meshes can be plotted using the plot() function on the mesh object. Once the mesh is plotted, the locations of the samples (stored in the Loc object) can be overlayed using points(). Below, the two meshes are plotted side-by-side.

## Making the projector matrix and the spde 

Once the 2d mesh is made we construct a observation/prediction weight matrix for the model. This is also called the "projector matrix".
```{r, eval=TRUE, echo=TRUE}
# 2. Define the weighting factors a_ik (also called the projector matrix).
A1      <- inla.spde.make.A(mesh  = mesh1a, loc   = Loc)
dim(A1)
```
The first dimension of the projector matrix has the size of the number of observations (here `r dim(A1)[1]`), and the second dimension of the projector matrix is the number of nodes in the mesh (here `r dim(A1)[2]`).
```{r, eval=TRUE, echo=TRUE}
# 3. Define the spde
spde  <- inla.spde2.matern(mesh1a)

w.st <- inla.spde.make.index('w', n.spde = spde$n.spde)
```

## Making the stack

The stack allows INLA to build models with complex linear predictors. Here have a SPDE model combined with covariate fixed effects and an intercept at n hauls.

Before making the stack we need to convert all fixed effects that are factors in the INLA model.
```{r, eval=T, echo=T}
cpue_subset$fYear   <- as.factor(cpue_subset$Year)
cpue_subset$fSurvey <- as.factor(cpue_subset$Survey)
```

Note that in code below the names in the model matrix should not contain any special characters! This is why we renamed the "NS-IBTS" survey to "NSIBTS"
```{r, eval=T, echo=T}
# 5. Make a stack. In this process we tell INLA at which points on the mesh we sampled the response variable and the covariates. 
Xmatrix <- model.matrix(~ fYear + fSurvey +  surface,  data = cpue_subset)
```

This Xmatrix contains the model matrix with the fixed effects, including the intercept (The column for the intercept is named "(Intercept)", and it is 1 for all observations). However, in the next step the intercept is removed from the model matrix. The intercept is then included when making the stack, and named "Intercept" (without brackets).

```{r, eval=T, echo=T}
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack1 <- inla.stack(
    tag  = "Fit",
    data = list(y = cpue_subset$NoPerHaul),    
    A    = list(1,1, A1),                      
    effects = list( 
       Intercept=rep(1,N),
       X=X, #Covariates
       w=w.st))                  #Spatial field
```

Note that N is the number of rows (`r N`) in the data set, and thus equal to the first dimension of A1. 

## Making the model formula and running the INLA model

The model formula used in the inla model is generated from the names of the model matrix, combined with the intercept term and the spatial correlation model ("f(w, model=spde)").

Subsequently, two inla models are run, one assuming that the data are Poisson distributed, and another model assuming that the data are negative binomial distributed.

```{r, eval=T, results='hide', echo=T, message=FALSE, warning=FALSE}
fsp <- parse(text=c("y ~ -1 + Intercept + ",paste(c(names(X)," f(w, model = spde)"),collapse =" + ")))

INLA:::inla.dynload.workaround() 
I1p <- inla(eval(fsp), family = "poisson", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))

I1nb <- inla(eval(fsp), family = "nbinomial", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))
```
Once the INLA models are run, a summary can be printed for the two models. This summary contains much of the relevant information for the models.

```{r, eval=T, echo=T}
summary(I1p)

summary(I1nb)
```

We'll plot the spatial mean and sd, but this time with a grid size of 1 by 1 km. Because the sampling locations are on a km grid, we can first find the ranges of the x and y coordinates of the grid, and then have grid cells of size 1.
```{r, eval=T, echo=T, fig.width=8, fig.height=4, dpi=600}
# we want to make cells of 1 by 1 km. Let's do this first 
xl <- range(Loc[,1])
xres <- round(xl[2]-xl[1])
yl <-  range(Loc[,2])
yres <- round(yl[2]-yl[1])

wproj <- inla.mesh.projector(mesh1a, dims=c(xres,yres), xlim = xl, ylim = yl) 

wm.pm100100  <- inla.mesh.project(wproj, I1nb$summary.random$w$mean)
wsd.pm100100 <- inla.mesh.project(wproj, I1nb$summary.random$w$sd)
    
grid     <- expand.grid(x = wproj$x, y = wproj$y)
grid$zm  <- as.vector(wm.pm100100)   
grid$zsd <- as.vector(wsd.pm100100)   

wld <- map('world', xlim=c(-5,15), ylim=c(47,62),plot=FALSE)
wld <- data.frame(lon=wld$x, lat=wld$y)

UTMmap <- project(cbind(wld$lon, wld$lat), "+proj=utm +zone=31U ellps=WGS84")
UTMmapFinal <- data.frame("xm"  =UTMmap[,1]/1e3, "ym" = UTMmap[,2]/1e3)

p1 <- levelplot(zm ~ x * y  ,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15+0.1, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

p2 <- levelplot(zsd ~ x * y,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior sd spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15+0.1, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

grid.arrange(p1,p2, ncol=2)
  
```

Next we want to simulate 1000 realizations and integrate over surface (per year) so that we get a population level estimate.  

To go from number to weiht we need alpha and beta from growth curve (for length in cm and resulting W is in kg )
alpha=0.156650
beta=2.190 ref is bedford et al. 1986
```{r, eval=T, echo=T}

# Step 2: Simulate regression parameters We use the function inla.posterior.sample 
# to simulate from the model. The output is stored in the Sim object.

set.seed(1234)
NSim <- 10
Sim <- inla.posterior.sample(n = NSim, result = I1nb)

names(Sim[[1]])
length(Sim[[1]]$latent)
#get out names of different types of rows in latent
rnames <- rownames(Sim[[1]]$latent)
rtypes <- unique(unlist(lapply(strsplit(rnames,":"),function(x){x[1]})))
rtypes

rtypes[1]
length(grep(paste0("^",rtypes[1]),rownames(Sim[[1]]$latent)) )

rtypes[2]
length(grep(paste0("^",rtypes[2]),rownames(Sim[[1]]$latent)) )

rtypes[3]
wrownum <- grep(paste0("^",rtypes[3]),rownames(Sim[[1]]$latent))
length(wrownum )

wmat <- sapply(Sim, function(x) {x$latent[wrownum]})
dim(wmat)
apply(wmat,1,"mean")

MyParams <- c("Intercept", "fYear2014", "fYear2015", "fYear2016","fYear2017", "fSurveyNSIBTS", "surface")
lrownum <- unlist(lapply(MyParams, function(x) {grep(x, rownames(Sim[[1]]$latent), fixed = TRUE)}    ))
lrownum
Sim[[1]]$latent[rownum]

linmat <- sapply(Sim, function(x) {x$latent[lrownum]})


```

Sim is thus an object that has ...


```{r, eval=FALSE, echo=T}


#NOTE THAT WE SHOULD THINK ABOUT how distance works in model because of log link

#NOTE THAT YEARS DO NOT WORK YET HERE (NEED MORE WORK ON fixed effects)

numbers <- matrix(NA, ncol=5, nrow=NSim, dimnames=list("sim"=1:NSim,"year"=startyr:2017))

for (ii in startyr:2017){
  for (jj in 1:NSim){
            #intercept    (1 times beta for distance)
    lin <- linmat[1,jj] + 1 * linmat[7,jj]
    
    wm.pm100100  <- inla.mesh.project(wproj, wmat[,jj])
    
    res <- exp(lin + wm.pm100100 )
    numbers[jj,as.character(ii)] <- sum(res,na.rm=T)
    
  }
}




for (i in 1: NSim){
  Betas <- SimData[[i]]$latent[as.numeric(rownum)]
  wk    <- SimData[[i]]$latent[2442:3633]
  FixedPart   <- Xm %*% Betas
  SpatialPart <- Am %*% wk
  mu.i[,i]    <- exp(FixedPart + SpatialPart)
  Ysim[,i]    <- rpois(n = nrow(LP), lambda = mu.i[,i])
}
table(Ysim[,1])
table(Ysim[,2])
table(Ysim[,3])

# Don't try to understand all the fancy code below Just the principle is enough.

# RUN FROM HERE.....
Z <- matrix(nrow = max(Ysim)+1, ncol = NSim)
for (i in 1: NSim){
	zi <- table(Ysim[,i])
	I <- as.numeric(names(zi)) + 1
	Z[I,i] <- zi
}

par(mfrow = c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
Z[is.na(Z)] <- 0
Xi <- 0: max(Ysim)
AverageTable <- rowSums(Z) / NSim

AverageTable <- rowSums(Z) / NSim
apply(Z, 1, mean)
SD <- apply(Z, 1, sd)

Zs <- table(LP$nSIE)
nx <- length(Zs)
NamesZ <- as.numeric(names(Zs))

plot(x = Xi, y = AverageTable, type = "h", lwd = 5, xlab = "Simulated endemic richness values", ylab = "Frequencies", ylim = c(0, 250))
		
# Add SDs
for (i in 1:nx){
    segments(x0 = NamesZ[i], x1 = NamesZ[i], y0 = AverageTable[i], y1 = AverageTable[i] + SD[i],lwd = 15,col = 1)
}
		
#And add the table for the observed data
for (i in 1:nx){
    segments(x0 = NamesZ[i] + 0.2, x1 = NamesZ[i] + 0.2, y0 = 0, y1 = Zs[i],	lwd = 2,	col = 2)
}

# The red bars represent the frequency table for the observed data. The black lines is
# the average frequency table for the 1000 simulated data sets. They should hopefully 
# match. If they do then the model simulates data that is comparable to the observed data.		

# It is not perfect. We are predicting too many zeros, but not enough ones and twos.
		
#############################################
# Now that we have 1000 simulated data sets from the model, what else shall we do with these simulated 
# data sets?

# We could calculate the number of zeros in each of the 1,000 data sets.
zeros <- vector(length = NSim)
for(i in 1:NSim){
	zeros[i] <- sum(Ysim[,i] == 0)
}

table(zeros)

# From the 1,000 simulated data sets, in 2 simulated data sets we had 1141 zeros. In 2 simulated data sets
# we had 1148 zeros,etc...... Your results will be different as mine.

# Just type 
Ysim[,1]
Ysim[,2]
Ysim[,3]
#etc

#Let's plot this as a table
plot(table(zeros), 
     #axes = FALSE,
     xlab = "How often do we have 0, 1, 2, 3, etc. number of zeros",
     ylab = "Number of zeros in 1000 simulated data sets",
     xlim = c(50, 150),
     main = "Simulation results")
points(x = sum(LP$nSIE == 0), y = 0, pch = 16, cex = 5, col = 2)
# The red dot is the number of zeros in the original data set.
# The data simulated from the Poisson model contains to many zeros.
#########################################

#########################################
# What else can we do with the 1,000 simulated data sets? We can also calculate the dispersion statistic for each
# simulated data set

p <- length(Betas) + 2    #Number of regression parameters
Dispersion <- vector(length = NSim) #Create space

# Calculate the dispersion for each simulated data set
for(i in 1:NSim){
	e2 <- (Ysim[,i] - mu2) /sqrt(mu2)
	Dispersion[i] <- sum(e2^2) / (N - p)
}

# Plot this as a table
hist(Dispersion,
     xlab = "Dispersion",
     ylab = "Frequency",
     xlim = c(0.6, 1.5),
     breaks = 25)

# And visualize the dispersion for the original Poisson GLMM
points(x = Dispersion2, 
       y = 0, 
       pch = 16, 
       cex = 3, 
       col = 2)
# The red dot is the underdispersion in the original data set.
# We have serious underdispersion!
# Bugger.

# A Generalized Poisson model may work.
#
```


```{r, eval=FALSE, echo=T}

# Simulate from model I1nb

# Simulation study spatial Negbin model.
# First set random seed and the number of simulations
set.seed(12345)
NSim <- 1000

# Carry out the simulation
Sim <- inla.posterior.sample(n = NSim, result = I1nb)

# Now we have 1000 simulated betas and also 1000 spatial fields w 
# Use these to calculate 1000 times the expected values mu,
# and simulate count data from these using rpois

# X matrix
#Xm      <- model.matrix(~BreedingD.std + Rain.std, data = cpue_subset)
Xm <- model.matrix(~  fYear + fSurvey +  surface  ,  data = cpue_subset)

# Create space to store the information
N    <- nrow(cpue_subset)
Ysim <- matrix(nrow = N, ncol = NSim)
mu.i <- matrix(nrow = N, ncol = NSim)
Xm   <- as.matrix(Xm)
Am   <- as.matrix(A1)

# We are calculating a Fixed part (X * beta) and also the random part (A * w)
for (i in 1: NSim){
  Betas    <- Sim[[i]]$latent[c(987, 988, 989)]
  wk       <- Sim[[i]]$latent[416:986]
  eta      <- Xm %*% Betas + Am %*% wk
  mu.i[,i] <- exp(eta)
  Ysim[,i] <- rpois(n = nrow(OCW), lambda = mu.i[,i])
}

# Now we have 1,000 simulated count data sets from the model

# And plot the results of the simulation study
Z <- matrix(nrow = max(Ysim)+1, ncol = NSim)
for (i in 1: NSim){
	zi <- table(Ysim[,i])
	I <- as.numeric(names(zi)) + 1
	Z[I,i] <- zi
}

		
```

