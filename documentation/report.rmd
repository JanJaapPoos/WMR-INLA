# Distribution map using survey data
## An example of Starry ray in the North Sea, using INLA
#### Authors: Geert Aarts, Niels Hintzen, Harriet van Overzee, Jurgen Batsleer, Jan Jaap Poos, Ingrid Tulp

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

Most of the data we collect at sea is spatially and temporally correlated, such as the International Bottom Trawl Survey (IBTS) or Beam Trawl survey data (BTS) survey data. Often we want to infer temporal or spatial trends in these data.

The statistical package INLA has the advantage over other software in R that it can combine spatial, temporal, zero-inflated, random effects etc models all in one. It therefore is very powerful and may become your one-stop-to-go package. 

This document shows some examples of analyzing survey data using INLA. The first model estimates the number of individuals per haul, taking account of haul location (assuming spatial autocorrelation) and year (as a 'fixed effect'). Differences in counts as a result of the two surveys are accounted for by also having survey as a fixed effect. Subsequent models take lengths into account in determining the counts. In the final part, the counts are expressed per unit area, so population estimates can be made using a 'swept area' approach.    
## Preparing the R environment

```{r, eval=T, echo=FALSE}
rm(list=ls())
```

First, we need to set the path where the data is located and to load the relevant libraries. The inla package can be installed using install.packages("INLA", repos="https://inla.r-inla-download.org/R/stable"). We need the inla package, but also a number of packages for spatial analyses ('rgeos' and 'rgdal')  and for plotting the data and the results ('lattice', 'latticeExtra', 'grid','gridExtra','mapdata', and 'maptools').

```{r, eval=T, results="hide", echo=TRUE, message=FALSE, warning=FALSE}
#path <- "~/WMR-INLA/data"
path <- "d://WMR-INLA/data" 

library(INLA); library(fields); 
library(mgcv)
library(lattice); library(latticeExtra); library(grid); library(gridExtra);
library(rgdal); library(rgeos); 
library(mapdata); library(maptools)
```

## The IBTS data

We will use the BTS and IBTS data set. In this case we downloaded the data for starry ray. These dataset contains the CPUE per length per haul can be dowloaded from datras.ices.dk. 

First we read in the IBTS dataset. From these data, the hauls in the North Sea are selected by keeping only those that are in (roundfish)areas 1-7. 

```{r, eval=T, echo=TRUE}
IBTS <- read.csv(file.path(path,"CPUE per length per haul_2017-07-12 11_18_36.csv"), stringsAsFactors = F)
IBTS <- IBTS[IBTS$Area <= 7,]
```

The lengths are stored in mm and the CPUE is stored as number per hour. "Zero hauls" are included (hauls where no individuals are counted)

```{r, eval=T, echo=TRUE}
IBTS$NoPerHaul <- round(IBTS$CPUE_number_per_hour*(IBTS$HaulDur/60))

IBTS <- within(IBTS, haulCode <-  paste0(Year, Survey, Quarter, Ship, HaulNo, ShootLat, ShootLong))
```

To get swept area information for the IBTS we need to read in the HH records of the IBTS. These HH records are available in the IBTS exchange files. The swept areas can be calculated from the travelled distance and the door spread or wing spread. Missing values for thease variables are coded as -9. In the r code those are made into NAs. We make a haul identifier for the hauls like we did for the count data. 

```{r, eval=T, echo=T}
IBTSHH <- read.csv(file.path(path,"Exchange Data_2017-07-14 09_26_25.csv"), stringsAsFactors = F)

IBTSHH <- within(IBTSHH, haulCode <-  paste0(Year, Survey, Quarter, Ship, HaulNo, ShootLat, ShootLong))

IBTSHH[IBTSHH$DoorSpread == -9,]$DoorSpread <- NA
IBTSHH[IBTSHH$Distance == -9,]$Distance <- NA
IBTSHH[IBTSHH$WingSpread == -9,]$WingSpread <- NA
``` 

Next, we plot a histogram of haul duration, a scatterplot of distance versus haul duration, and a scatterplot of doorspread versus wingspread to get a look at the data. Clearly, haul duration is stored in minutes, with most of the hauls being either 30 minutes or 1 hour. Hauls longer than 80 minute are removed because these contain a large proportion of outliers with respect to e.g. distance. This step removes `r sum(IBTSHH$HaulDur > 80)` from the `r nrow(IBTSHH)` hauls.

The wing spread and doorspread are stored in meters, with wing spreads being in the range `r range(IBTSHH$WingSpread, na.rm=T)` meters and doorspread being in the range  `r range(IBTSHH$DoorSpread, na.rm=T)` meters. There is one clear outlier 

```{r, eval=TRUE, echo=TRUE, dpi=600}
par(mfrow=c(1,3))
hist(IBTSHH$HaulDur,120, xlim=c(0,120), main= "", xlab="Haul duration (minutes)")
abline(v=80, lty=2)
IBTSHH <- IBTSHH[IBTSHH$HaulDur <= 80,]

plot(IBTSHH$HaulDur,IBTSHH$Distance, pch=20, xlab="Haul duration (minutes)", ylab= "Distance (m)")

plot(IBTSHH$WingSpread,IBTSHH$DoorSpread, pch=20, xlab="Wingspread (m)", ylab= "Doorspread (m)")
abline(a=0,b=1, lty=2)
```

A surface is calculated by multiplying  wing spread by distance. Both are in metres. The resulting surface is thus in m2. This is converted to km2 by dividing by 1e+06.
```{r, eval=T, echo=T}
IBTSHH$surface <- (IBTSHH$Distance * IBTSHH$WingSpread)/1e+06
```

Next, only relevant variables are selected.
```{r, eval=T, echo=T}
IBTSHH <- IBTSHH[names(IBTSHH) %in% c("haulCode", "surface", "HaulDur","Doorspread","Distance","WingSpread")]
```

Ploting the surface against haul duration and using a simple linear model (without intercept) we hope to find a relationship. 
```{r, eval=TRUE, echo=TRUE, dpi=600}
plot(x=IBTSHH$HaulDur,y=IBTSHH$surface, pch=20, main= "IBTS", xlab= "Haul duration ( minutes)", ylab="Surface (km2)", xlim=c(0,80))
linmod <- lm(surface~ -1 + HaulDur, data=IBTSHH)
summary(linmod)
abline(linmod, lty=2)
```

Indeed, there is a good relationship, where each minute of haul duration adds `coef(linmod)` km2 haul surface for the IBTS. This relationship is used to calculate the surface of hauls where only haul duration is known.   
```{r, eval=TRUE, echo=TRUE, dpi=600}
IBTSHH[is.na(IBTSHH$surface),]$surface <- as.numeric(predict(linmod,newdata=IBTSHH))[is.na(IBTSHH$surface)]
```

Merge the haul information to the full cpue set, after removing haulduration from the  haul data (because we have it in the CPUE set already)
```{r, eval=T, echo=T}
IBTSHH$HaulDur <- NULL
IBTS <- merge(IBTS, IBTSHH,by= "haulCode", all.x=T, all.y=F)
```

After this merge, there are `nrow(IBTS[is.na(IBTS$surface),])` observation in the IBTS data set that do not have a surface estimate, because their haul duration was larger than the treshold used in our calculations. 

## The BTS data

We have a similar but slightly different data set for BTS. Here, the "zero hauls" have lengthclass NA and the number per haul is NA. These observations are then set to zero, so that we have the same structure as in the IBTS data set. 

```{r, eval=TRUE, echo=TRUE}
BTS  <- read.csv(file.path(path,"CPUE per length per Hour and Swept Area_2017-07-12 11_29_36.csv"), stringsAsFactors = F)

BTS[is.na(BTS$LngtClass),]$NoPerHaul <- 0
BTS[is.na(BTS$LngtClass),]$LngtClass <- 0
```

Which vessels and years are present in BTS set? Note that there are some years in the BTS ISIS where the zero hauls are not added because no specimens were caught in that year (e.g. 2010). That should be fixed at ICES. Alternatively we could download the data with a more abundant species and make our own zero hauls.
```{r, eval=TRUE, echo=TRUE}
table(BTS$Ship, BTS$Year)
```
The BTS swept area estimate is rounded, and thus not very useful. That's why we will recalculate it: the distance and beam width are in m, so the surface is in m2, and divided by 1e+06 to get km2
```{r, eval=TRUE, echo=TRUE}
# there are some negative distances. We make those  NA, and infer their surface later 
BTS[!is.na(BTS$Distance) & BTS$Distance < 0,]$Distance <- NA

#now calculate surface
BTS$surface <- (BTS$Distance * BTS$BeamWidth)/1e+06

# summary of the surface gives number of NAs, and whether there are negative values
summary(BTS$surface)
summary(BTS$HaulDur)
```

We use the same procedure of inferring haul surface from haul duration for the missing surfaces of the BTS as we did for IBTS.
```{r, eval=TRUE, echo=TRUE, dpi=600}
plot(x=BTS$HaulDur,y=BTS$surface, pch=20, main= "BTS", xlab="Haul duration (minutes)", ylab="Surface (km2)", xlim=c(0,80))
linmod <- lm(surface~ -1 + HaulDur, data=BTS)
summary(linmod)
abline(linmod, lty=2)

BTS[is.na(BTS$surface),]$surface <- as.numeric(predict(linmod,newdata=BTS))[is.na(BTS$surface)]
```

Indeed, there is a good relationship, where each minute of haul duration adds `coef(linmod)` km2 haul surface for BTS. This relationship is used to calculate the surface of hauls where only haul duration is known.   

Next, we make a unique haul code for the BTS, as we did for IBTS
```{r, eval=TRUE, echo=TRUE}
#make haul code
BTS <- within(BTS, haulCode <- paste0(Year, Survey, Quarter, Ship, HaulNo, ShootLat, ShootLong))
```

The BTS and IBTS datasets need to be combined the two sets into one, using rbind() to combine them by rows. The datasets can only be combined if they have the same columns. The columns that are shared by the two data sets are found using intersect().
```{r, eval=TRUE, echo=TRUE}
cols <- intersect(colnames(BTS), colnames(IBTS))
cpue <- rbind(BTS[,cols],IBTS[,cols])

#remove CPUE per hour that we do not need now that we have counts
cpue <- cpue[,!names(cpue)=="CPUE_number_per_hour"]
```

Now that the IBTS and BTS data sets are combined we want to make a set where we have counts for all hauls and all lenghts. This means first making an dentifier for each unique haul (based on the information we have for all the hauls). This identifier is used to make a "trawllist" where all the information for the hauls is stored together with its unique identifier.

Once the trawllist is make we use expand.grid() to make a combination of all hauls and lenght classes. This set is merged with our original data set.
```{r, eval=TRUE, echo=TRUE}
trawllist <- cpue[!duplicated(cpue$haulCode),!names(cpue) %in% c("Species","AphiaID","NoPerHaul","Sex", "LngtClass")]

#expand grid 
hxl <- expand.grid(haulCode=unique(cpue$haulCode),LngtClass=unique(cpue$LngtClass), stringsAsFactors = F)
full_cpue <- merge(hxl,cpue[names(cpue) %in% c("haulCode", "LngtClass","NoPerHaul")], all.x=T)
rm(hxl)
```

After we merged all possible combinations with the data we now have NAs for those lengts and hauls where the catch is zero, and so we set those to zero. This data is subsequently merged to the trawllist so that we have all information together. 
```{r, eval=TRUE, echo=TRUE}
full_cpue[is.na(full_cpue$NoPerHaul),]$NoPerHaul <- 0
full_cpue  <- merge(full_cpue,trawllist, all.x=T)
```

The records that have lenghts equal to zero (that indicated zero hauls in our original set ) now need to be removed because we have all the information we need (these hauls now have zero catch for the full length range observed in the survey). 

```{r, eval=TRUE, echo=TRUE}
#now remove zero lengths
full_cpue <- full_cpue[full_cpue$LngtClass > 0,]
```

In addition, there are some observations that are highly unlikely: For instance there is a single observation of an individual of 100 cm (in 1977). This is highly suspicious because it is far larger than than any other observation, and likely due to species mis-identification. This can be seen in the histogram of length observations below. 

```{r, eval=TRUE, echo=TRUE, dpi=600}
par(mfrow=c(1,2))
len_cutoff <- 990
hist(full_cpue[full_cpue$Quarter==1 & full_cpue$NoPerHaul >0,]$LngtClass, breaks=100, xlab="Length (mm)", main="Observed lengths q1",xlim=c(0, max(full_cpue$LngtClass)), ylim=c(0,1500))
abline(v=len_cutoff, col="red")
grid()
lines(aggregate(NoPerHaul~LngtClass, data=full_cpue[full_cpue$Quarter==1 & full_cpue$NoPerHaul >0,], FUN="sum"))

hist(full_cpue[full_cpue$Quarter==3 & full_cpue$NoPerHaul >0,]$LngtClass, breaks=100, xlab="Length (mm)", main="Observed lengths q3",xlim=c(0, max(full_cpue$LngtClass)), ylim=c(0,1500))
abline(v=len_cutoff, col="red")
grid()
lines(aggregate(NoPerHaul~LngtClass, data=full_cpue[full_cpue$Quarter==3 & full_cpue$NoPerHaul >0,], FUN="sum"))
```

Ideally, we would go back to data and the people who collected the data to see if the correctness of the data can be confirmed. In this case there is no possibility to go back so far back in time. We remove these observation from the dat by selecting only observations with length < `r len_cutoff` mm. One could even consider removing the observations of individuals larger than 750 mm. Some of these were recorded in the Southern North Sea, far from where most of the catches were made. Those are likely species misidentification, e.g. with R. clavata. Note that when the length information is included in the analyses a further selection is made for the lengths.
```{r, eval=TRUE, echo=TRUE}
#remove single unlikely large individual (of 1 m length) 
full_cpue <- full_cpue[full_cpue$LngtClass < len_cutoff,]
head(full_cpue)
```

For our spatial correlation we will need an isomorphic coordinate system. Therefore we transform the latitudes and longitudes to UTM coordinates. these UTM coordinates are given in meters, so we divide them by 1000 to get kilometers.
```{r, eval=TRUE, echo=TRUE}
UTM <- project(cbind(full_cpue$ShootLong, full_cpue$ShootLat), "+proj=utm +zone=31U ellps=WGS84") 

full_cpue$Xkm <- UTM[,1]/1000
full_cpue$Ykm <- UTM[,2]/1000
```

The INLA code does not like special characters in some of the variable names, like the hyphen in "NS-IBTS". Therefore we rename the survey to NSIBTS. 
```{r, eval=TRUE, echo=TRUE}
full_cpue <- transform(full_cpue, Survey=gsub("-","",Survey))
```

### Depth data 
We try to also add depth to the model and we prepare for this now. We have depth for many but not all hauls in the full cpue set. The maximum fishing depth for IBTS standard stations in the North Sea is 200 m. and in Division IIIa 250 m. However, there are some hauls taken at depths deeper than 300 m. and we exclude those. The missing values are indicated by a value of -9, and these have to be transformed into NAs.
```{r, eval=T, echo=T}
summary(full_cpue$Depth)
full_cpue <- full_cpue[full_cpue$Depth < 300,]
full_cpue[full_cpue$Depth ==-9,]$Depth <- NA
summary(full_cpue$Depth)
``` 

Given that the depth for a given location does not change much over the years, we use a generalized additive model to model a depth map, and to predict depths for those hauls where depth is missing. Using the depth in INLA requires that the depth is binned. We use 2 m depth bins. 

```{r, eval=T, echo=T}
depthmodel <- gam(Depth ~ te(ShootLong,ShootLat,k=20), data=full_cpue[!duplicated(full_cpue$haulCode),])
summary(depthmodel)
gam.check(depthmodel)
plot(depthmodel)
full_cpue[is.na(full_cpue$Depth),]$Depth <-predict(depthmodel,newdata= full_cpue[is.na(full_cpue$Depth),])
full_cpue$Depth <- round(full_cpue$Depth/2,0)*2
```
The resulting depth map can be seen by plotting the fitted values of the depth model at each observations.

```{r, eval=T, echo=T, dpi=600}
lons <- full_cpue[!duplicated(full_cpue$haulCode),]$ShootLon
lats <- full_cpue[!duplicated(full_cpue$haulCode),]$ShootLat
preds <- predict(depthmodel,newdata= data.frame(ShootLong=lons,ShootLat=lats ))

plot(lons,
     lats,
     pch=20,
     col=rev(tim.colors(15, alpha = 1))[cut(preds,20)], 
     xlab= "Longitude", ylab="latitude", las=1)
map("world",add=T)

``` 


### Subsetting and length aggregation

We still have a lot of data (`r nrow(full_cpue)`), Because these are just here as example, we will subset the data, and start our analysis from a fiven year. That year is stored in startyr.    
```{r, eval=TRUE, echo=TRUE}
startyr <- 2015
cpue_subset <- full_cpue[full_cpue$Year >= startyr,]
```

In this example we thus start from `r startyr`.  The earlier we start, the more information we will obtain from the analysis on the annual changes in the count data. However, including more data also means we require more memory to store the model, and wait longer for the model to run. If too much data is used in the inla model, so that more computer memory is required than you have available, the model will crash. Now we have `r  nrow(cpue_subset)` rows left in cpue_subset. 

```{r, eval=T, echo=TRUE}
cpue_subset <- aggregate(NoPerHaul ~ haulCode + Survey +  Quarter + Ship + Gear  + HaulNo + Year + HaulDur + surface + ShootLong + ShootLat +  Xkm + Ykm +  Depth, data= cpue_subset,FUN="sum")
```
After the aggregation (now that the length information is removed) we have `r  nrow(cpue_subset)` rows in the data set. To give us a quick impression of the data we plot it in a map. The two surveys have different colors, black being the BTS hauls, red being the IBTS hauls in quarter 1 and blue being the IBTS hauls in quarter 3. The size of the circles indicate the counts in each haul.
```{r, eval=T, echo=TRUE, dpi=600}
par(mfrow=c(1,2))
plot(cpue_subset$ShootLong,cpue_subset$ShootLat, 
     cex=0.1, 
     col=c('black', 'red','blue')[as.factor(paste(cpue_subset$Survey, cpue_subset$Quarter))],
     xlab="Longitude", ylab="Lattitude", main="Location of all hauls" )
map("world",add=T)

plot(cpue_subset$ShootLong,cpue_subset$ShootLat, 
     cex=log(cpue_subset$NoPerHaul)/5, 
     col=c('black', 'red','blue')[as.factor(paste(cpue_subset$Survey, cpue_subset$Quarter))],
     xlab="Longitude", ylab="Lattitude",  main="Counts per hauls" )
map("world",add=T)
```
Clearly the IBTS hauls cover a larger part of the North Sea, but the large catches are located in the same areas. 

### The count data

We plot a quick histogram of the counts to give us an impression of the statistical distribution of the data.

```{r, eval=T, echo=TRUE, dpi=600}
par(mfrow=c(1,3))
hist(cpue_subset[cpue_subset$Survey == "BTS",]$NoPerHaul, 200, xlab= "Number per haul", main="Counts per haul BTS")
hist(cpue_subset[cpue_subset$Survey == "NSIBTS" &cpue_subset$Quarter == 1,]$NoPerHaul, 200, xlab= "Number per haul", main="Counts per haul IBTS q1")
hist(cpue_subset[cpue_subset$Survey == "NSIBTS" &cpue_subset$Quarter == 3,]$NoPerHaul, 200, xlab= "Number per haul", main="Counts per haul IBTS q3")

```

The count data is clearly quite skewed, with lots of zeros and small values, and very few large counts. Because of this distribution and because  these are counts, a Poisson and a negative binomial distribution will be used in the inla model. We will also test if zero-inflation provides better fits to the data.  

## Making a spatial mesh for the data

The UTM coordinates of the data set are combined into a Loc (location) dataset. That data set will be used later to generate spatial meshes for the data.   
```{r, eval=T, echo=TRUE}
Loc <- cbind(cpue_subset$Xkm , cpue_subset$Ykm )
```

Next we need a mesh for the spatial data. Because we do not want our spatial correlations to pass landmasses (e.g. Denmark) we first make a nonconvex hull of the data points using inla.nonconvex.hull(). This convex hull is used as a boundary for making a 2d mesh. The generation of the actual mesh is done using inla.mesh.2d(). That function takes several arguments, incuding "cutoff" and "max.edge". These arguments specify how fine the final mesh will be. Finer meshes will be able to capture smaller scale spatial correlations, but require more comuting time in the inla model.

```{r, eval=T, echo=TRUE}
ConvHull <- inla.nonconvex.hull(Loc, convex=-0.02, resolution=90)
mesh1a   <- inla.mesh.2d(boundary = ConvHull,  max.edge=c(30))
```

As an alternative to using the nonconvex hull function to generate a boundary,, we can also take the shapefile of the North Seaas the boundary of the mesh, which makes prediction in the future easier, as we know no record can be found outside the North Sea area (give or take evolution). We first load the ICES shapefiles which were downloaded from http://gis.ices.dk/sf/. We load this shapefiles, merge layers together, transform to UTM, convert UTM to km rather than meters and finally create a mesh. 
```{r, eval=T, echo=TRUE}
ICESareas <- readShapePoly(file.path(path,"ICES_Areas_20160601_dense"))
NorthSea  <- subset(ICESareas,SubArea==4)
NorthSea  <- gUnionCascaded(NorthSea)
proj4string(NorthSea) <- c("+proj=longlat")
NorthSeaUTM <- spTransform(NorthSea,CRS("+proj=utm +zone=31"))

NS.border <- inla.sp2segment(NorthSeaUTM)
NS.border$loc <- NS.border$loc/1000

mesh1b      <- inla.mesh.2d(boundary=NS.border, cutoff=3,max.edge=c(30))
```

The meshes can be plotted using the plot() function on the mesh object. Once the mesh is plotted, the locations of the samples (stored in the Loc object) can be overlayed using points(). Below, the two meshes are plotted side-by-side.

```{r, eval=T, echo=TRUE, dpi=600}
par(mfrow=c(1,2))
plot(mesh1a)
points(Loc, col = 1, pch = 16, cex = 0.3)
plot(mesh1b)
points(Loc, col = 1, pch = 16, cex = 0.3)
```

## Making the projector matrix and the spde 

Once the 2d mesh is made we construct a observation/prediction weight matrix for the model. This is also called the "projector matrix".
```{r, eval=T, echo=TRUE}
# 2. Define the weighting factors a_ik (also called the projector matrix).
A1      <- inla.spde.make.A(mesh  = mesh1a, loc   = Loc)
dim(A1)
```
The first dimension of the projector matrix has the size of the number of observations (here `r dim(A1)[1]`), and the second dimension of the projector matrix is the number of nodes in the mesh (here `r dim(A1)[2]`).
```{r, eval=T, echo=TRUE}
# 3. Define the spde
spde  <- inla.spde2.matern(mesh1a)

w.st <- inla.spde.make.index('w', n.spde = spde$n.spde)
```

## Making the stack

The stack allows INLA to build models with complex linear predictors. Here have a SPDE model combined with covariate fixed effects and an intercept at n hauls.

Before making the stack we need to convert all fixed effects that are factors in the INLA model.
```{r, eval=T, echo=T}
cpue_subset$fYear   <- as.factor(cpue_subset$Year)
cpue_subset$fSurvey <- as.factor(cpue_subset$Survey)
```

Because of the link function of the Poisson and negative binomial that we will be using we need to log-transform the surfaces and haul durations to get a linear response later. 
```{r, eval=T, echo=T}
cpue_subset$lsurface   <- log(cpue_subset$surface)
cpue_subset$lhauldur   <- log(cpue_subset$HaulDur)
```

Note that in code below the names in the model matrix should not contain any special characters! This is why we renamed the "NS-IBTS" survey to "NSIBTS"
```{r, eval=T, echo=T}
# 5. Make a stack. In this process we tell INLA at which points on the mesh we sampled the response variable and the covariates. 
Xmatrix <- model.matrix(~ fYear + fSurvey +  lhauldur,  data = cpue_subset)
head(Xmatrix)
```

This Xmatrix contains the model matrix with the fixed effects, including the intercept (The column for the intercept is named "(Intercept)", and it is 1 for all observations). However, in the next step the intercept is removed from the model matrix. The intercept is then included when making the stack, and named "Intercept" (without brackets).

```{r, eval=T, echo=T}
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack1 <- inla.stack(
    tag  = "Fit",
    data = list(y = cpue_subset$NoPerHaul),    
    A    = list(1,1, A1),                      
    effects = list( 
       Intercept=rep(1,N),
       X=X, #Covariates
       w=w.st))                  #Spatial field
```

## Making the model formula and running the INLA model

The model formula used in the inla model is generated from the names of the model matrix, combined with the intercept term and the spatial correlation model ("f(w, model=spde)").

Subsequently, two inla models are run, one assuming that the data are Poisson distributed, and another model assuming that the data are negative binomial distributed.

```{r, eval=T, results='hide', echo=T, message=FALSE, warning=FALSE}
fsp <- parse(text=c("y ~ -1 + Intercept + ",paste(c(names(X)," f(w, model = spde)"),collapse =" + ")))

INLA:::inla.dynload.workaround() 
I1p <- inla(eval(fsp), family = "poisson", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))

I1nb <- inla(eval(fsp), family = "nbinomial", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))

I1zip <- inla(eval(fsp), family = "zeroinflatedpoisson1", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))

I1zinb <- inla(eval(fsp), family = "zeroinflatednbinomial1", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))
```
Once the INLA models are run, a summary can be printed for the two models. This summary contains much of the relevant information for the models. Below is the example for the Poisson model. The summary also  contains the WAIC criterion. WAIC works just like AIC in that the model with the lowest WAIC should be selected.

```{r, eval=T, echo=T}
summary(I1p)
summary(I1p)$waic$waic
```

The Poisson model this has a WAIC value of `r summary(I1p)$waic$waic`. We can make a simple table to compare the WAIC values of the different models.

```{r, eval=T, echo=T}
dic2  <- c(I1p$dic$dic, I1nb$dic$dic, I1zip$dic$dic, I1zinb$dic$dic)
waic2 <- c(I1p$waic$waic, I1nb$waic$waic, I1zip$waic$waic, I1zinb$waic$waic)
Z     <- cbind(dic2, waic2)
rownames(Z) <- c("Poisson model",  "Negative binomial model", "Zero Inflated Poisson model",  "Zero Inflated Negative binomial model" )
Z
```

The negative binomial model has the lowest DIC and WAIC. Let's see the summary of this model.  
```{r, eval=T, echo=T}
summary(I1nb)
```
Plot the histograms of observations and fits for all models. 

```{r, eval=T, echo=T, dpi=600}
idx <- inla.stack.index(Stack1, tag= 'Fit')$data

par(mfrow=c(2,2))
pos <- barplot(log(table(cpue_subset$NoPerHaul)),names.arg=as.numeric(names(table(cpue_subset$NoPerHaul))),ylim=c(0,log(max(table(cpue_subset$NoPerHaul),na.rm=T))*1.3),main="Poisson model")
breaks <- c(as.numeric(names(table(cpue_subset$NoPerHaul))),1000)
points(y=log(table(cut(I1p$summary.fitted.values[idx,"mean"],breaks=breaks))),x=pos[,1],col=2,pch=19)

pos <- barplot(log(table(cpue_subset$NoPerHaul)),names.arg=as.numeric(names(table(cpue_subset$NoPerHaul))),ylim=c(0,log(max(table(cpue_subset$NoPerHaul),na.rm=T))*1.3),main="Negative binomial model")
breaks <- c(as.numeric(names(table(cpue_subset$NoPerHaul))),1000)
points(y=log(table(cut(I1nb$summary.fitted.values[idx,"mean"],breaks=breaks))),x=pos[,1],col=2,pch=19)

pos <- barplot(log(table(cpue_subset$NoPerHaul)),names.arg=as.numeric(names(table(cpue_subset$NoPerHaul))),ylim=c(0,log(max(table(cpue_subset$NoPerHaul),na.rm=T))*1.3),main="ZIP model")
breaks <- c(as.numeric(names(table(cpue_subset$NoPerHaul))),1000)
points(y=log(table(cut(I1zip$summary.fitted.values[idx,"mean"],breaks=breaks))),x=pos[,1],col=2,pch=19)

pos <- barplot(log(table(cpue_subset$NoPerHaul)),names.arg=as.numeric(names(table(cpue_subset$NoPerHaul))),ylim=c(0,log(max(table(cpue_subset$NoPerHaul),na.rm=T))*1.3),main="ZINB model")
breaks <- c(as.numeric(names(table(cpue_subset$NoPerHaul))),1000)
points(y=log(table(cut(I1zinb$summary.fitted.values[idx,"mean"],breaks=breaks))),x=pos[,1],col=2,pch=19)
```

```{r, eval=T, echo=T,  dpi=600}
# Spatial info
SpatField.w <- inla.spde2.result(inla = I1nb, name = "w", spde = spde, do.transfer = TRUE)

Kappa <- inla.emarginal(function(x) x, 
                        SpatField.w$marginals.kappa[[1]] )

Sigma_u <- inla.emarginal(function(x) sqrt(x), 
                        SpatField.w$marginals.variance.nominal[[1]] )

range <- inla.emarginal(function(x) x, 
                        SpatField.w$marginals.range.nominal[[1]] )

Kappa; Sigma_u; range       #Distance at which the correlation diminishes

# Show correlation structure
LocMesh <- mesh1a$loc[,1:2]

# And then we calculate the distance between each vertex.
D <- as.matrix(dist(LocMesh))

# Using the estimated parameters from the model (see above)
# we can calculate the imposed Matern correlation values.
d.vec <- seq(0, max(D), length = 100)      
Cor.M <- (Kappa * d.vec) * besselK(Kappa * d.vec, 1) 
Cor.M[1] <- 1

# Which we plot here:
par(mfrow=c(1,1))
plot(x = d.vec, y = Cor.M, 
     type = "l", 
     xlab = "Distance", 
     ylab = "Correlation")
abline(h = 0.1, lty = 2)
```


```{r, eval=T, echo=F, fig.width=8, fig.height=4, dpi=600}
wproj <- inla.mesh.projector(mesh1a, xlim = range(Loc[,1]), ylim = range(Loc[,2])) 

wm.pm100100  <- inla.mesh.project(wproj, I1nb$summary.random$w$mean)
wsd.pm100100 <- inla.mesh.project(wproj, I1nb$summary.random$w$sd)
    
grid     <- expand.grid(x = wproj$x, y = wproj$y)
grid$zm  <- as.vector(wm.pm100100)   
grid$zsd <- as.vector(wsd.pm100100)   

wld <- map('world', xlim=c(-5,15), ylim=c(47,62),plot=FALSE)
wld <- data.frame(lon=wld$x, lat=wld$y)

UTMmap <- project(cbind(wld$lon, wld$lat), "+proj=utm +zone=31U ellps=WGS84")
UTMmapFinal <- data.frame("xm"  =UTMmap[,1]/1e3, "ym" = UTMmap[,2]/1e3)

p1 <- levelplot(zm ~ x * y  ,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

p2 <- levelplot(zsd ~ x * y,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior sd spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

grid.arrange(p1,p2, ncol=2)
  
```

Wat happens here?

```{r, eval=FALSE, echo=T}

tcoo <- rbind(c(0.3, 0.3), c(0.5, 0.5), c(0.7, 0.7))
inla.nonconvex.hull
dim(Ap <- inla.spde.make.A(mesh = mesh1, loc = tcoo))
## [1] 3 505
x0 <- c(0.5, 0.5, 0.5)
#To do a fully Bayesian analysis, we include the target locations on the estimation process by
#assigning NA for the response at these locations. Defining the prediction stack
stk.pred <- inla.stack(tag='pred', A=list(Ap, 1), data=list(y=NA), ## response as NA
effects=list(s=1:spde$n.spde, data.frame(x=x0, b0=1)))
#Fit the model again with the full stack

stk.full <- inla.stack(stk.e, stk.pred)
p.res <- inla(formula, data=inla.stack.data(stk.full), ## full stack
control.predictor=list(compute=TRUE, ## compute the predictor
A=inla.stack.A(stk.full))) ## using full stack data
#Get the prediction data index and collect the PMD to work with
pred.ind <- inla.stack.index(stk.full, tag = "pred")$data
ypost <- p.res$marginals.fitted.values[pred.ind]
#Visualize PMD for the linear predictor at target locations with commands bellow
names(ypost) <- paste('y', seq_along(ypost), sep='_'); library(plyr)
xyplot(y~x | .id, ldply(ypost), panel='llines', xlab='y', ylab='Density')
#In INLA we have some functions to work with marginals distributions
apropos("marginal")
## [1] "inla.dmarginal" "inla.emarginal" "inla.hpdmarginal"
## [4] "inla.mmarginal" "inla.pmarginal" "inla.qmarginal"
## [7] "inla.rmarginal" "inla.smarginal" "inla.tmarginal"
inla.mmarginal(ypost[[1]]) ## mode
## [1] 1.697
inla.qmarginal(c(0.15, 0.7), ## quantiles
ypost[[1]])
## [1] 1.345 1.875
inla.pmarginal(inla.qmarginal(
0.3, ypost[[1]]), ypost[[1]])
## [1] 0.3

```


## Using swept area estimates


### Making the stack
Note that in code below the names in the model matrix should not contain any special characters! This is why we renamed the "NS-IBTS" survey to "NSIBTS"
```{r, eval=T, echo=T}
# 5. Make a stack. In this process we tell INLA at which points on the mesh we sampled the response variable and the covariates. 
Xmatrix <- model.matrix(~ fYear + fSurvey +  lsurface,  data = cpue_subset)
```

This Xmatrix contains the model matrix with the fixed effects, including the intercept (The column for the intercept is named "(Intercept)", and it is 1 for all observations). However, in the next step the intercept is removed from the model matrix. The intercept is then included when making the stack, and named "Intercept" (without brackets).

```{r, eval=T, echo=T}
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack1 <- inla.stack(
    tag  = "Fit",
    data = list(y = cpue_subset$NoPerHaul),    
    A    = list(1,1, A1),                      
    effects = list( 
       Intercept=rep(1,N),
       X=X, #Covariates
       w=w.st))                  #Spatial field
```

Note that N is the number of rows (`r N`) in the data set, and thus equal to the first dimension of A1. 

### Making the model formula and running the INLA model

The model formula used in the inla model is generated from the names of the model matrix, combined with the intercept term and the spatial correlation model ("f(w, model=spde)").

Subsequently, two inla models are run, one assuming that the data are Poisson distributed, and another model assuming that the data are negative binomial distributed.

```{r, eval=T, results='hide', echo=T, message=FALSE, warning=FALSE}
fsp <- parse(text=c("y ~ -1 + Intercept + ",paste(c(names(X)," f(w, model = spde)"),collapse =" + ")))

INLA:::inla.dynload.workaround() 
I1p <- inla(eval(fsp), family = "poisson", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))

I1nb <- inla(eval(fsp), family = "nbinomial", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE),
           control.predictor = list(A = inla.stack.A(Stack1)))
```
Once the INLA models are run, the information criteria and summaries can be printed for the models. This summary contains much of the relevant information for the models, including the WAIC.

```{r, eval=T, echo=T}
dic2  <- c(I1p$dic$dic, I1nb$dic$dic)
waic2 <- c(I1p$waic$waic, I1nb$waic$waic)
Z     <- cbind(dic2, waic2)
rownames(Z) <- c("Poisson model",  "Negative binomial model" )
Z
```

```{r, eval=T, echo=T}
summary(I1nb)
```

We'll plot the spatial mean and sd, but this time with a grid size of 1 by 1 km. Because the sampling locations are on a km grid, we can first find the ranges of the x and y coordinates of the grid, and then have grid cells of size 1.
```{r, eval=T, echo=T, fig.width=8, fig.height=4, dpi=600}
# we want to make cells of 1 by 1 km. Let's do this first 
xl <- range(Loc[,1])
xres <- round(xl[2]-xl[1])
yl <-  range(Loc[,2])
yres <- round(yl[2]-yl[1])

wproj <- inla.mesh.projector(mesh1a, dims=c(xres,yres), xlim = xl, ylim = yl) 

wm.pm1km2  <- inla.mesh.project(wproj, I1nb$summary.random$w$mean)
wsd.pm1km2 <- inla.mesh.project(wproj, I1nb$summary.random$w$sd)
    
grid     <- expand.grid(x = wproj$x, y = wproj$y)
grid$zm  <- as.vector(wm.pm1km2)   
grid$zsd <- as.vector(wsd.pm1km2)   

wld <- map('world', xlim=c(-5,15), ylim=c(47,62),plot=FALSE)
wld <- data.frame(lon=wld$x, lat=wld$y)

UTMmap <- project(cbind(wld$lon, wld$lat), "+proj=utm +zone=31U ellps=WGS84")
UTMmapFinal <- data.frame("xm"  =UTMmap[,1]/1e3, "ym" = UTMmap[,2]/1e3)

p1 <- levelplot(zm ~ x * y  ,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

p2 <- levelplot(zsd ~ x * y,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior sd spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
           
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

grid.arrange(p1,p2, ncol=2)
  
```

Next we want to simulate a number realizations and integrate over surface (per year) so that we get a population level estimate.  

```{r, eval=T, echo=T}
# Simulate regression parameters using inla.posterior.sample 
# to simulate from the model. The output is stored in the Sim object.

set.seed(1234)
NSim <- 500
Sim <- inla.posterior.sample(n = NSim, result = I1nb)
```

In this example, we thus sample `r NSim` times. The Sim object is a list of length NSim. Each element of  this list contains a single realization. Let's have a closer look.

```{r, eval=T, echo=T}
names(Sim[[1]])

#get out names of different types of rows in latent
rnames <- rownames(Sim[[1]]$latent)
rtypes <- unique(unlist(lapply(strsplit(rnames,":"),function(x){x[1]})))
rtypes
```
There are thus a number of different types of rows in latent: APredicto, Predictor, W, and the fixed effects.

```{r, eval=T, echo=T}
#to get the w par realizations out: 
rtypes[3]
wrownum <- grep(paste0("^",rtypes[3]),rownames(Sim[[1]]$latent))
wmat <- sapply(Sim, function(x) {x$latent[wrownum]})
dim(wmat)

#to get the fixed effect par realizations out 
fixed <- rtypes[-(1:3)]
lrownum <- unlist(lapply(fixed, function(x) {grep(x, rownames(Sim[[1]]$latent), fixed = TRUE)}    ))
linmat <- sapply(Sim, function(x) {x$latent[lrownum]})
dim(linmat)
dimnames(linmat)[[1]] <- fixed
```

Sim is thus an object that has ...

length(wm.pm1km2[!is.na(wm.pm1km2)]) contains surface of grid

```{r, eval=T, echo=T}
numbers <- matrix(NA, ncol=length( startyr:2017), nrow=NSim, dimnames=list("sim"=1:NSim,"year"=startyr:2017))

for (ii in startyr:2017){
  for (jj in 1:NSim){
            #intercept  +           year                         +  ( 0 times beta for lsurface (so we get 1 km))
    if (ii==startyr){
      lin <- linmat["Intercept",jj] +                                 0 * linmat["lsurface",jj]
    }else{
      lin <- linmat["Intercept",jj] + linmat[paste0("fYear",ii),jj] + 0 * linmat["lsurface",jj]
    }
    # section below is for including spatial corr 
    wm.pm1km2  <- inla.mesh.project(wproj, wmat[,jj])
    #only take non-NAs
    wm.pm1km2 <- wm.pm1km2[!is.na(wm.pm1km2)]
    res <- exp(lin + wm.pm1km2 )
    numbers[jj,as.character(ii)] <- sum(rnbinom(n=length(res),mu=res,size=I1nb$summary.hyperpar$mean[1]))
  }
}
```

Number is the estimated number for the entire surface of the grid
what are the conf bounds for numbers per year?

```{r, eval=T, echo=T}
qnumbers <- apply(numbers,2, quantile,c(0.025,0.5,0.975))
matplot(t(qnumbers), xlab="Years", ylab="Population numbers")
```

what are the average weights per year?
To go from number to weight we need alpha and beta from growth curve (for length in cm and resulting W is in g )
alpha=0.156650
beta=2.190 ref is Bedford et al. 1986

```{r, eval=T, echo=T}
alpha <- 0.156650
beta <- 2.190
full_cpue$wt <-  (alpha * (full_cpue$LngtClass/10)^beta * full_cpue$NoPerHaul) /1000
annualmnwt <- aggregate(cbind(wt,NoPerHaul) ~ Year, data= full_cpue,  FUN= "sum") 
annualmnwt <- within(annualmnwt, mnwt <- wt/NoPerHaul)

plot(mnwt~Year, data=annualmnwt, type="b")
```

Multiply weights by population numbers to get estimated population biomass. Divide by 1e6 to go from kg to 1000 tonnes. 

```{r, eval=T, echo=T}
qwts <- annualmnwt[annualmnwt$Year >= startyr,]$mnwt * qnumbers / 1e6
```


```{r, eval=T, echo=T}
matplot(t(qwts), xlab="Years", ylab="Estimated Total Stock Weight (1000 tonnes)", las=1, ylim=c(0,max(qwts)))
```

## Including depth in the swept area estimation


```{r, eval=T, echo=T}
N <- nrow(cpue_subset)
Stack1 <- inla.stack(
    tag  = "Fit",
    data = list(y = cpue_subset$NoPerHaul),    
    A    = list(1,1,1, A1),                      
    effects = list( 
       Intercept=rep(1,N),
       X=X, #Covariates
       Depth = cpue_subset$Depth,
       w = w.st))                  #Spatial field

#6.	Specify the model formula
fsp <- parse(text=c("y ~ -1 + Intercept + ",paste(c(names(X)," f(w, model = spde)", ' f(Depth,model="rw2")'),collapse =" + ")))
```

```{r, eval=T, echo=T}
INLA:::inla.dynload.workaround() 
I1nb <- inla(eval(fsp), family = "nbinomial", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE, openmp.strategy="large"),
           control.predictor = list(A = inla.stack.A(Stack1)))

summary(I1nb)

```

```{r, eval=T, echo=T}
#plot depth smoother
Depthm <- I1nb$summary.random$Depth

par(mfrow = c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
plot(Depthm[,1:2], type='l',
     xlab = 'Depth', 
     ylab = 'Smoother',
     ylim = c(-3, 2) )
abline(h=0, lty=3)
lines(Depthm[, c(1, 4)], lty=2)
lines(Depthm[, c(1, 6)], lty=2)
rug(cpue_subset$Depth)
```

```{r, eval=T, echo=T, fig.width=8, fig.height=4, dpi=600}
# we want to make cells of 1 by 1 km. Let's do this first 
xl <- range(Loc[,1])
xres <- round(xl[2]-xl[1])
yl <-  range(Loc[,2])
yres <- round(yl[2]-yl[1])

wproj <- inla.mesh.projector(mesh1a, dims=c(xres,yres), xlim = xl, ylim = yl) 

wm.pm100100  <- inla.mesh.project(wproj, I1nb$summary.random$w$mean)
wsd.pm100100 <- inla.mesh.project(wproj, I1nb$summary.random$w$sd)
    
grid     <- expand.grid(x = wproj$x, y = wproj$y)
grid$zm  <- as.vector(wm.pm100100)   
grid$zsd <- as.vector(wsd.pm100100)   

wld <- map('world', xlim=c(-5,15), ylim=c(47,62),plot=FALSE)
wld <- data.frame(lon=wld$x, lat=wld$y)

UTMmap <- project(cbind(wld$lon, wld$lat), "+proj=utm +zone=31U ellps=WGS84")
UTMmapFinal <- data.frame("xm"  =UTMmap[,1]/1e3, "ym" = UTMmap[,2]/1e3)

p1 <- levelplot(zm ~ x * y  ,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset$Xkm,
                        y = cpue_subset$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset$NoPerHaul/15, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

p2 <- levelplot(zsd ~ x * y,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior sd spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

grid.arrange(p1,p2, ncol=2)
  
```


```{r, eval=FALSE, echo=T}

# Simulate from model I1nb
set.seed(1234)
NSim <- 500
Sim <- inla.posterior.sample(n = NSim, result = I1nb)
```

In this example, we thus sample `r NSim` times. The Sim object is a list of length NSim. Each element of  this list contains a single realization. Let's have a closer look.

```{r, eval=T, echo=T}
names(Sim[[1]])

#get out names of different types of rows in latent
rnames <- rownames(Sim[[1]]$latent)
rtypes <- unique(unlist(lapply(strsplit(rnames,":"),function(x){x[1]})))
rtypes

```

```{r, eval=T, echo=T}
#to get the w par realizations out: 
rtypes[3]
wrownum <- grep(paste0("^",rtypes[3]),rownames(Sim[[1]]$latent))
wmat <- sapply(Sim, function(x) {x$latent[wrownum]})
dim(wmat)

#to get the depth realizations out: 
rtypes[4]
drownum <- grep(paste0("^",rtypes[4]),rownames(Sim[[1]]$latent))
dmat <- sapply(Sim, function(x) {x$latent[drownum]})
dim(dmat)


#to get the fixed effect par realizations out 
fixed <- rtypes[-(1:3)]
lrownum <- unlist(lapply(fixed, function(x) {grep(x, rownames(Sim[[1]]$latent), fixed = TRUE)}    ))
linmat <- sapply(Sim, function(x) {x$latent[lrownum]})
dim(linmat)
dimnames(linmat)[[1]] <- fixed
```

dmat thus has dimensions nsim, number of depth bins and the estimate of the snoorther for each depth bin present in the data. If we want to project on spatial grid, we thus may need to interpolate for depth that are in the depth matrix. The depth matrix should be modeled on the UTM grid rather than on lat lon, that is easier when combining the depth part of the prediction and te spatiotemporal part.

## Including depth in the swept area estimation and spatio temporal-correlation


```{r, eval=TRUE, echo=TRUE}
# 2. Define the weighting factors a_ik (also called the projector matrix).
endyr <- max(cpue_subset$Year)
t.mesh <- inla.mesh.1d(loc = startyr:endyr)

A1     <- inla.spde.make.A(mesh = mesh1a,
                          loc   = Loc,
                          group = cpue_subset$Year,
                     group.mesh = t.mesh)

dim(A1)
```

The first dimension of the projector matrix has the size of the number of observations (here `r dim(A1)[1]`), and the second dimension of the projector matrix is the number of nodes in the mesh (here `r dim(A1)[2]`).

```{r, eval=TRUE, echo=TRUE}
# 3. Define the spde
spde  <- inla.spde2.matern(mesh1a)

w.st <- inla.spde.make.index('w', 
                             n.spde = spde$n.spde,
                             n.group = length(startyr:endyr))
```



```{r, eval=T, echo=T}
N <- nrow(cpue_subset)
Stack1 <- inla.stack(
    tag  = "Fit",
    data = list(y = cpue_subset$NoPerHaul),    
    A    = list(1,1,1, A1),                      
    effects = list( 
       Intercept=rep(1,N),
       X=X, #Covariates
       Depth = cpue_subset$Depth,
       w = w.st))                  #Spatial field

#6.	Specify the model formula
fsp <- parse(text=c("y ~ -1 + Intercept + ",paste(c(names(X)," f(w, model = spde, group = w.group, control.group = list(model = 'ar1'))", ' f(Depth,model="rw2")'), collapse =" + ")))
```

```{r, eval=T, echo=T}
INLA:::inla.dynload.workaround() 
I1nb <- inla(eval(fsp), family = "nbinomial", data=inla.stack.data(Stack1),
           control.compute = list(dic = TRUE, waic = TRUE, config=TRUE, openmp.strategy="large"),
           control.predictor = list(A = inla.stack.A(Stack1)))

summary(I1nb)

```

```{r, eval=T, echo=T}
#plot depth smoother
Depthm <- I1nb$summary.random$Depth

par(mfrow = c(1,1), mar = c(5,5,2,2), cex.lab = 1.5)
plot(Depthm[,1:2], type='l',
     xlab = 'Depth', 
     ylab = 'Smoother',
     ylim = c(-2, 2) )
abline(h=0, lty=3)
lines(Depthm[, c(1, 4)], lty=2)
lines(Depthm[, c(1, 6)], lty=2)
rug(cpue_subset$Depth)
```


```{r, eval=F, echo=T, fig.width=8, fig.height=4, dpi=600}
# we want to make cells of 1 by 1 km. Let's do this first 
xl <- range(Loc[,1])
xres <- round(xl[2]-xl[1])
yl <-  range(Loc[,2])
yres <- round(yl[2]-yl[1])

wproj <- inla.mesh.projector(mesh1a, dims=c(xres,yres), xlim = xl, ylim = yl) 

grid <- expand.grid(year=startyr:endyr, x = wproj$x, y = wproj$y,zm=NA)

for (i in startyr:endyr){
    w.pm1km2 <- inla.mesh.project(wproj,w.st[w.st$w.group==which(i==Year)])
    grid[grid$length==i,]$zm <- as.vector(w.pm1km2)  
}

wld <- map('world', xlim=c(-5,15), ylim=c(47,62),plot=FALSE)
wld <- data.frame(lon=wld$x, lat=wld$y)

UTMmap <- project(cbind(wld$lon, wld$lat), "+proj=utm +zone=31U ellps=WGS84")
UTMmapFinal <- data.frame("xm"  =UTMmap[,1]/1e3, "ym" = UTMmap[,2]/1e3)

p1 <- levelplot(zm ~ x * y|year  ,
          data = grid, 
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset[cpue_subset$Year == grid[subscripts[1],]$year,]$Xkm,
                        y = cpue_subset[cpue_subset$Year == grid[subscripts[1],]$year,]$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset[cpue_subset$Year ==grid[subscripts[1],]$year,]$NoPerHaul/15, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black')

```








## Including length in the analysis

Owing to ontogenetic niche shifts we expect that the spatial distribution of small indivduals is different from the spatial distribution of large indivuals. Hence we want to include a length component in the spatial distribution of the counts.

First we need to make a new subset of the data that includes the length information (and leaving out the aggregation step in our earlier analysis). We use the same starting year as was done for the previous analysis: `r startyr`.

```{r, eval=TRUE, echo=TRUE}
# make selection of  fullset.
cpue_subset <- full_cpue[full_cpue$Year >= startyr,]
```

Let's make 5 cm classes instead of 1 cm classes. This reduces the number of observations. We use round to achieve this. Remember that the units of the length measurements is mm. 

Once we have 5 cm lenght classes, we need aggregate() to sum the numbers per haul within our new length bins. Becaus we need the other info in the data set as well we include all variables in the aggregate. 

```{r, eval=TRUE, echo=TRUE}
cpue_subset$LngtClass <- round(cpue_subset$LngtClass/50)*50

cpue_subset <- aggregate(NoPerHaul~ LngtClass + haulCode + Survey + Quarter + Ship + Gear  + HaulNo + Year + HaulDur + ShootLong +
                                    ShootLat + Xkm + Ykm +  Depth, data= cpue_subset,FUN="sum")
```


Below, we inspect the length range of observations. There are no individuals with lengths over 600 mm observed. Hence, we remove those lengthclasses. If there are too many subsequent lenght classes with only zeros, the model will fail, giving a warning that one of the eigenvalues is negative.  

```{r, eval=T, echo=T}
aggregate(NoPerHaul~LngtClass, data=cpue_subset, FUN= "sum")
cpue_subset <- cpue_subset[cpue_subset$LngtClass >   0,]
cpue_subset <- cpue_subset[cpue_subset$LngtClass < 650,]
```

As before, The UTM coordinates of the observations are combined into a Loc (location) dataset. That dataset is used to create a mesh in the next step.  
```{r, eval=TRUE, echo=TRUE}
Loc <- cbind(cpue_subset$Xkm , cpue_subset$Ykm )
```

Next we need a mesh for the spatial data. Because we do not want our spatial correlations to pass landmasses (e.g. Denmark) we first make a convex hull of the data points using inla.nonconvex.hull(). This convex hull is used as a boundary for making a 2d mesh. 

```{r, eval=TRUE, echo=TRUE}

ConvHull <- inla.nonconvex.hull(Loc, convex=-0.02, resolution=90)
mesh2a    <- inla.mesh.2d(boundary = ConvHull,  max.edge=c(30))
plot(mesh2a)
points(Loc, col = 1, pch = 16, cex = 0.5)
```

Next we inspect the length range in the data by making a histogram of length observations. This histogram can be used to define the locations ofa number of "knots" along the length range that we will later use for our analysis. More knots means a longer computing time (but a higher degree of flexibility in the length component of the spatial correlation). 

There are no individuals with lengths over 680 mm observed. Hence, we remove those lengthclasses (with only zeros) from the data set and define the knots to be within the new length range 

```{r, eval=T, echo=T}
hist(cpue_subset$LngtClass,200, main="", xlab="Length class (mm)")
knots <- seq(from = 50, to = 550, by = 100)
knots 
```

Using the `r length(knots)` knots as locations, we make a 1 dimensional mesh.   
```{r, eval=T, echo=T}
  
# One-dimensional mesh for length class. See the time series module
mesh.t <- inla.mesh.1d(loc = knots)
```

In this mesh.t object, the dimensions can be checked using mesh.t$loc (for the locations) and mesh.t$n (the number of locations). The code below confirms that there are `r mesh.t$n` locations, and those are at the values of the knots object. 
```{r, eval=T, echo=T}
mesh.t$n
mesh.t$loc
```
 
Now that there is a 1 dimensional mesh for the lengths, we use it to construct a observation/prediction weight matrix ("projector matrix") based on the spatial mesh that we already created earlier (mesh1) and our new mesh for the lengths. The lengths are used in the "group model". The new projector matrix is names A2 to distinguish it from the projector matrix of the previous model.

```{r, eval=T, echo=T}
# 2. Define the weighting factors a_ik (projector matrix).
NGroups <- length(knots) 
A2      <- inla.spde.make.A(mesh  = mesh2a,
                            loc   = Loc,
                            group = cpue_subset$LngtClass, 
                       group.mesh = mesh.t)
dim(A2) 

# 3. Define the spde
spde  <- inla.spde2.matern(mesh2a)
```

We need to make an inla.spde model object for a Matern model, but we still have that available from the model without size structure. That object was named "spde". We use it to make a list of named index vectors for the SPDE model. Note that the command for making the list of index vectors now includes an argument for the groups. 

```{r, eval=T, echo=T}
w.st <- inla.spde.make.index('w', 
                             n.spde = spde$n.spde, 
                             n.group = NGroups)
```


Before making the stack we need to convert all fixed effects that are factors in the INLA model.
```{r, eval=T, echo=T}
cpue_subset$fYear   <- as.factor(cpue_subset$Year)
cpue_subset$fSurvey <- as.factor(cpue_subset$Survey)
```

Next we make a new stack. For this we need a model matrix. Although the fixed effects are the same as in the previous model, we still need to make a new model matrix because the data now include the length structure. 

```{r, eval=T, echo=T}
# 5. Make a stack. 
Xmatrix <- model.matrix(~  fYear + fSurvey +  HaulDur,  data = cpue_subset)

head(Xmatrix)
```
This Xmatrix contains the model matrix with the fixed effects, including the intercept (The column for the intercept is named
 "(Intercept)", and it is 1 for all observations). However, in the next step the intercept is removed from the model matrix.
 The intercept is then included when making the stack, and named "Intercept" (without brackets). 

```{r, eval=T, echo=T}
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack2 <- inla.stack(
  tag  = "Fit",
  data = list(y = cpue_subset$NoPerHaul),    
  A    = list(1,1, A2),                      
  effects = list(  
    Intercept = rep(1, N),       
    X = as.data.frame(X), # Covariates
    w = w.st))                # Spatial-temp field  

```

```{r, eval=T, echo=T}
fsp <- parse(text=c("y ~ -1 + Intercept + ",
                    paste(c(names(X)," f(w, model = spde, group =       w.group, control.group = list(model = 'ar1'))"),collapse =" + ")))
```

```{r, eval=F, echo=T}
I2nb <- inla(eval(fsp), family = "nbinomial",
           data=inla.stack.data(Stack2),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack2)))
```

```{r, eval=F, echo=T}
summary(I2nb)
```

We still have The "UTMmap" object for creating the maps from the previous analysis.

```{r, eval=F, echo=T}
w <- I2nb$summary.random$w$mean
# length of w is mesh$n * NGroups
wproj <- inla.mesh.projector(mesh2a, xlim = range(Loc[,1]), ylim = range(Loc[,2])) 

grid <- expand.grid(length=knots, x = wproj$x, y = wproj$y,zm=NA)

for (i in knots){
    w.pm100100 <- inla.mesh.project(wproj,w[w.st$w.group==which(i==knots)])
    grid[grid$length==i,]$zm <- as.vector(w.pm100100)  
}
```

Next we print the grid, which is now estimated at each knot. The observed counts for the length class at each knot are included in each panel. 
```{r, eval=F, echo=T, dpi=600}
print(levelplot(zm ~ x * y |length,
          data = grid,
          scales = list(draw = TRUE),
          xlab = list("Easting", cex = 1),
          ylab = list("Northing", cex = 1),
          main = list("Posterior mean spatial random fields", cex = 1),
          col.regions=tim.colors(25, alpha = 1),
          panel=function(x, y, z, subscripts,...){
            panel.levelplot(x, y, z, subscripts,...)
            grid.points(x = cpue_subset[cpue_subset$LngtClass == grid[subscripts[1],]$length,]$Xkm,
                        y = cpue_subset[cpue_subset$LngtClass == grid[subscripts[1],]$length,]$Ykm, 
                        pch = 1,
                        size = unit(cpue_subset[cpue_subset$LngtClass ==grid[subscripts[1],]$length,]$NoPerHaul/15, "char"))  
          }) +  xyplot(ym~ xm, UTMmapFinal, type='l', lty=1, lwd=0.5, col='black'))
```

## Including length in the survey catchability

```{r, eval=F, echo=T}
# 5. Make a stack. 
Xmatrix <- model.matrix(~  fYear + fSurvey + HaulDur,  data = cpue_subset)
X <- as.data.frame(Xmatrix[,-1])
names(X) <- c(gsub("[:]",".",names(X)))
head(X)

N <- nrow(cpue_subset)
Stack3 <- inla.stack(
  tag  = "Fit",
  data = list(y = cpue_subset$NoPerHaul),    
  A    = list(1,1, A2),                      
  effects = list(  
    Intercept = rep(1, N),       
    X = as.data.frame(X), # Covariates
    w.st))                # Spatial-temp field  

```

```{r, eval=FALSE, echo=T}
fsp <- parse(text=c("y ~ -1 + Intercept + ",
                    paste(c(names(X)," f(w, model = spde, group =       w.group, control.group = list(model = 'ar1'))", "f(LngtClass, group=fSurvey,'rw2')",collapse =" + ")))
```

```{r, eval=FALSE, echo=T}
I3nb <- inla(eval(fsp), family = "nbinomial",
           data=inla.stack.data(Stack3),
           control.compute = list(dic = TRUE, waic = TRUE),
           control.predictor = list(A = inla.stack.A(Stack3)))
```

```{r, eval=FALSE, echo=T}
summary(I3nb)
```
